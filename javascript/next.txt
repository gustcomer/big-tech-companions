list of special files:

<Layout>                                              layout.tsx
  <Template>                                          template.tsx
    <ErrorBoundary fallback={<Error />}>              error.tsx
      <Suspense fallback={<Loading />}>               loading.tsx
        <ErrorBoundary fallback={<NotFound />}>       not-found.tsx
          <Page />                                    page.tsx
        </ErrorBoundary>
      </Suspense>
    </ErrorBoundary>
  </Template>
</Layout>

================================================================================
Initial Project

go to the folder where you want to create the folder for the project
  > npx create-next-app@latest

================================================================================
Nextjs glossary

[...]: check Catch-all Segments.
[slug]: check Dynamic Route.
API Routes: allow you to create server-side endpoints as part of your application. These endpoints can be used to handle HTTP requests and serve as a backend for your application without requiring a separate backend service.
  - in Vercel or similar platforms, each API route is deployed as a serverless function, which scales automatically.
  - Next.js API routes are powered by a lightweight library Micro similar to Express, developed by Vercel. Both Micro and Express are lightweight HTTP frameworks designed for handling server-side requests and responses.
App directory: directory responsible for all the routing.
  - to make it work, it has to have a page.tsx file inside the folder representing the routing. Check File Colocation.
Autoprefixer: lib that manages css prefixes like -webkit, -moz.
Caching: route handlers are not cached by default but you can opt into caching when using the GET method.
  - in development mode, each refresh means a a new Response, we don't cache. You have to test cache with builds.
  - to update the data from time to time, use revalidate. This is ISR (Incremental Static Regeneration).
  - export const dynamic = "force-static"; is a way to force cache.
  - export const dynamic = "force-dynamic"; is a way to opt out of cache.
  - PUT, DELETE and PATCH methods are never cached.
  - if you're using dynamic functions like headers(), cookies() or working with the request object in your GET method, caching won't be applied.
Caching Mechanisms:
  - Request Memoization
  - Data Cache
  - Full Route Cache
  - Router Cache
Catch-all Segments: extend dynamic segments to to catch-all subsequent segments.
  - add an ellipsis inside the brackets [...folderName]
  - all segments are passed at the params prop in an array form. (remember nested dynamic routes used key-value pairs).
  - app/shop/[...slug]/page.js will route /shop/a/b/c and generate params: { slug: ['a', 'b', 'c'] }
  - in the case above, if you want to also match app/, you should check Optional Catch-all Segments entry and use [[...slug]].
  eg: Could support languages in the route. Could be useful for categorizations.
Client Components:
  - they can use hooks, use event listeners and manage state.
  - client components can't be async, but can use async functions inside useEffect().
client-only: package that prevent unintended server side usage of client side code.
  - client code interact with browser-specific features like DOM, window object, localStorage, etc.
  - useful when you have a function in some util folder that are intended solely for client use.
  - ensures that the code stays where it belongs enhancing reliability and mantainability.
Client-Side Rendering (CSR): consists of rendering React components directly in the client's browser. The server sends a minimal html, then sends a .js bundle file which takes care of constructing all. If any fetch is needed, the client will be requesting to the server.
  - is used to generate SPA, pages which a minimal html is sent once and all the rest is taken care of by the js bundle.
  - component code is transformed into user interface directly in the browser.
  - not optimal for SEO.
  - performance issues since users might see a blank screen or a loading spinner while the page loads.
  - CSR laid the groundwork for interactive applications we see today, but lacks in SEO and performance.
  drawbacks
    - SEO: because the crawler will see only <div id='root'>.
    - performance of UI/UX: because your browser has to download the bundle, fetch data, build the UI, make everything interactive and only then show something.
Code Splitting: breaking up a large JavaScript bundle into smaller, more manageable chunks that can be loaded on-demand or in parallel.
  - it consists of a kind of Selective Hydration.
  - you can implement this using React.lazy() functionality.
Cookies: small pieces of data that a server sends to a user's web browser.
  - the browser may store the cookie and send it back to the same server with later requests.
  - use cases: session management, personalizations, tracking and analysis of user behavior.
  - to set a cookie, send a response with "Set-Cookie" header and name-value: "Set-Cookie": "theme=dark"
cookies(): function to manipulate cookies. you can use the cookies() function or alternatively, the request.cookies.get("...").
  - there are additional functionalities such as "has", delete, etc
Core Web Vitals: subset of Web Vitals.
  - consists of Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS).
Cumulative Layout Shift (CLS): measure of your site’s overall layout stability.
Data Cache: server-side cache that persists the result of data fetches across incoming server requests and deployments.
  - it improves app performance and eliminate the need to re-fetch data with every request.
  - in the Rendering phase, each fetch() checks if there is data on the Data Cache, if there aren't any, then it requests data to the Data Source.
  - the data is stored in .next/cache/fetch-cache
  - the Data Cache is a Server Cache, don't confuse it with the browser cache.
Data Fetching: process of retrieving data from an external source, such as an API, database, or file, to be used within a React application. Usually data is fetched from REST API or GraphQL, but also from databases, files, etc.
  - to fetch data from the Server Component, use async and await keywords in the component definition.
default.tsx: serves as a fallback to render content when the framework cannot retrieve a slot's active state from the current URL due to unmatched routes inside slots.
  - it's higly recommended that you have one default.tsx in each slot folder. You usually simply copy the code of the related page.tsx.
  - you should put a default.tsx in the parent folder that calls the slots as well.
  - this file processes slots without specific content for the route inside a slot.
  - I believe that you can put the same route inside different slots.
DELETE(): put this function inside a route.ts file to handle a DELETE request.
  - you can respond the request with return Response.json(...) or with return NextResponse.json({data})
  - export async function DELETE(_request: Request, {params}) {...}
Development Server: focuses on developer experience.
  - pages will be pre-rendered for every request
Dynamic Page Route: the process of putting a page.tsx inside a folder representing a dynamic route.
Dynamic Rendering: a Server Rendering Strategy where routes are rendered for each user at request time.
  - useful when a route has data that is personalized to the user or contains information that can only be known at request time, such as cookies or the URL's search parameters.
  - during rendering, if a dynamic function such as cookies() headers() searchParams are discovered, Next will switch to dynamically rendering automatically for the whole route.
  - dynamic routes are represented with a lambda sign.
Dynamic Route Handler: similar to Dynamic Page Route. Put a route.ts inside a folder representing a dynamic route.
  - useful for GET, PATCH, DELETE requests.
  - for GET: export async function GET(request: Request, { params }: { params: { id: string } })
Dynamic Routes: when you don't know the exact segment names ahead of time and want to create routes from dynamic data.
  - use Dynamic Segments for this purpose.
  - to use it you name the folder with square brackets, for example, [id] or [slug].
  snippet [https://github.com/gustcomer/schedmusic/commit/a9d6aedc7b8d1c8dea7fe971a6e6ba749c7297d1]
Dynamic Segment: when you don't know exact names of segment parts of the dynamic route, you can use Dynamic Segments to capture this dynamic data.
  - created by wrapping a folder's name in square brackets: [folderName]
  - they are passed as the params prop to layout, page, route, and generateMetadata functions.
Error
  Expected Errors: errors that can occur during the normal operation of the application, such as those from server-side form validation or failed requests.
    - you can use the useActionState() hook to manage the state of Server Functions and handle expected errors.
  Uncaught Exceptions: unexpected errors that indicate bugs or issues that should not occur during the normal flow of your application.
    - these should be handled by throwing errors, which will then be caught by error boundaries. Handle them using Error Boundaries via error.js
Error Boundary: in React it is a special type of component that catches JavaScript errors anywhere in its child component tree, logs those errors, and prevents the entire application from crashing due to an unhandled exception.
  - errors always bubble up to find the closest parent error boundary.
  - an error.tsx file handles errors not just for its own folder, but for all the nested child segments below it too. Place error.tsx files at different levels in your route folder to control exactly how detailed your error handling gets.
  - there's a catch with errors in Layouts and Templates. These errors won't be catch by the error.tsx because of the Component hyerarchy. Layouts and templates sits above the error boundary in the component tree.
    - you should place the error.tsx up one level in the hierarchy.
    - for errors in the root layout, check error.tsx:global-error.tsx
Error Handling: it is possible to throw Errors when dealing with App routes or API routes. To process the errors accordingly, we use the file error.tsx in the file based routing.
  - error boundaries must be client components in Next. 
  - a prop called error is passed to the Error component. You can get the error message from it.
  - in nested routes, errors bubble up to the closest parent error boundary.
  - taking into account the next structure, inserting an error.tsx will handle errors of the page at the same folder, but won't handle errors in the template nor the layout. To handle errors in the layout or in the template, you should place error.tsx one folder above.
  reset(): the error component also receives a reset() method, which allows to retry the rendering of the component without reloading the whole page, needless to say that it happens client side. This is used with temporary simple errors.
    - but there is a catch. The reset() method executes on the client, but Client Components have parts executed on the server and parts executed on the Client.
    - there are workarounds to this problem like changing the key to force a re-render on the server and even a bizarre one with startTransition().
error.tsx: file in the file based routing that define an Error Boundary. They must be client components.
  - the error component automatically creates a React Error Boundary that wraps a nested child segment or page.js component.
  - this error component receives and error object with an Error object containing information about the error.
  - also it receives a reset method, reset: () => void, that allows to retry if we end up in the Error Boundary (the Error Page).
  - by positioning error.tsx at different levels in the nested folders, you can achieve a more granular level of error handling.
  global-error.tsx: special file used for handling global error boundaries across your application. In this file, stuff like the <html> and <body> tags need also to be included. It should be simple, only html and css, so that no new errors are included.
fetch(): check Data Fetching.
File Colocation: practice of organizing and grouping related files together in the same directory.
  - but in the App folder responsible for the routing, the route only has visibility if it has a page.tsx file and an export default component.
First Load JS: size when downloading the page from the server
First Load JS shared by all: includes global css, some runtime code, framweork code, react code, code related to routes and components.
font: automatically optimize your fonts, for instance, self-hosting any Google Font.
  - to use the font, insert fontname.className in the class of the component.
generateMetadata(): function used to define dynamic metadata.
  - you cannot export a static metadata and a generateMetadata function at the same time.
GET(): put this function inside a route.ts file to handle a get request.
  - you can respond the request with return Response.json(...) or with return NextResponse.json({data})
  - export async function GET(_request: Request, {params}) {...}
globals.css: this is not an official next file, but it is delivered with the create-next-app. It is used in the root app folder to keep styles that apply globally accross the entire application. It is imported once at the layout.css at the root level.
headers: allows you to read the HTTP incoming request headers from a Server Components. Useful for more advanced tasks that use the http protocol, such as authorization, cookies, etc.
  - you can use the Header() function with the NextRequest (next/server) object, or the async header() function.
HTML Streaming: technique used to improve the performance of web applications by progressively sending chunks of HTML from the server to the client.
  - at first it does not include chunking the JavaScript code. To split the JavasScript bundle, check Code Splitting.
HTTP Headers: metadata associated with an API request and response.
Hydration: react takes control in the browser, reconstructing the component tree in memory based on the static HTML that was server.
  - for Selective Hydration and breaking up of the JavaScript bundle, check Code Splitting.
  - initialize application state
  - attach event handlers for actions
  - set up other dynamic functionalities
<Image>: 
  - required props: src, width, height, and alt.
  - fill(prop): causes the image to fill the parent element, which is useful when the width and height are unknown.
Independent Route Handling: each slot can have its own loading and error states.
Intercepting Routes: allows you to load a route from another part of your application within the current layout when navigation through <Link/>.
  - if you refresh the page or type the address directly, it will show the original page, and not the intercepted one.
  - use case: show login modal when you're navigating, but show login page when you share the link or refresh.
  - define naming a subfolder as /(.)routename , this way it opens /(.)routename when clicking <Link/> and /routname when refreshing or sharing the link.
  - if the route you want to intercept is at the same level of your current route, use /(..)routename.
  - (.) match segments on the same level.
  - (..) match segments one level above.
  - (..)(..) match segments two levels above (has bugs).
  - (...) match segments from the root app directory.
Interleaving: you can place a Server Component inside a Client Component passing the SC as a prop.
ISR (Incremental Static Regeneration): allows you to update static content without rebuilding the entire application.
  - it is enabled by using the revalidate option in Server Components.
  - if a user visits the site, next check if revalidate interval is expired. If the content is stale, it triggers a regeneration of the page.
    - the user that triggered the regeneration will still get the cached version, but future requests will then see the updated version.
key prop: string or a number that uniquely identifies items in an array.
Layout: UI that is shared between multiple routes. On navigation, layouts preserve state, remain interactive, and do not re-render.
  - The component should accept a children prop and this chindren component will be inserted into the UI.
  eg: set a header and footer that appears on every page.
  check: Nested Layout, Multiple Root Layout
layout.tsx: special file that is shared between multiple routes and defines UI.
  - export some component as default and with children props.
Layout Shifting: when a visible element on your page changes position or size, affecting the position of content around it.
Lazy: React.lazy is a function that allows you to render a dynamic import as a regular component. It is part of React's support for code splitting, enabling you to load components lazily, i.e., only when they are needed.
<Link>: component that extends the HTML <a> element to provide prefetching and client-side navigation between routes.
  - eg: <Link href="/blog">Blog</Link>
  - replace prop: when true, next/link will replace the current history state instead of adding a new URL into the browser’s history.
    eg: it means that the actual page containing the Link with replace won't be added to the history. Good to avoid Login pages, form pages, etc.
Loading UI: allows you to handle loading states efficiently using loading.tsx in the App Router. It's kinda the Suspense feature, but native to Next.js
  - part of the user experience when dealing with asynchronous operations, such as data fetching, lazy-loaded components, and route transitions.
  - the loading component wraps the page.tsx component in a Suspense boundary.
  - it is important because it gives instant feedback when users navigate somewhere new.
  - shared layouts can still be used, like navigation menus, sidebars, etc. (but not Layouts).
loading.tsx: this file allows us to create loading states that are displayed to users while a specific route segment's content is loading.
  - loading has to do with React Suspense.
Metadata API: allows you to define metadata for each page. It can be done in page.tsx or layout.tsx.
  - 2 methods: export a static metadata object or export a dynamic generateMetadata().
    - the generateMetadata() is much more complicated but on the other hand we can generate dynamic metadata like titles.
  - deeper page metadata will replace layout metadata if they have the same properties. Makes the content look good when sharing, and halp indexing by search engines.
  - while layout metadata will apply to all pages, page metadata apply only to the specific page. They follow a top-down order, meaning that page metadata will override layout metadata.
  - the metadata is rendered on the server so it should be placed on Server Components.
  check generateMetadata()
Middleware: allows you to run code before on the incoming request. You can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.
  - Use the file middleware.ts (or .js) in the root of your project to define Middleware.
  - the matcher config property is used to filter Middleware to run on specific paths.
  - it offers a robust way to intercept and control the flow of requests and responses within your applications.
  - aids redirection, URL rewrites, authentication, headers, cookies management, etc
  - we have different approaches to apply the middleware to a path
    - configure a matcher in a config file exported in the middleware file
    - use conditional conditions on request.nextUrl.pathname
  use cases: Auth, session validation, Feature Flags, A/B testing, Geo-targeting, SEO redirects, Custom Headers, Security Rules.
Multiple Root Layout: approach where an application has different top-level layout components depending on the section or type of page being rendered.
  - specific things like login page, dashboards, etc usualy don't share the same header and footer of the usual pages.
Nested Dynamic Routes: nested routes with more than one dynamic segment.
  - all dynamic segments will be passed as properties of Param props in the form of key-value pairs.
  - other way to capture multiple dynamic segments is using Catch All Segments.
  snippet [https://github.com/gustcomer/schedmusic/commit/258f336a77e0d526ebd5c42c4f3bb588cbbfaa4f]
Nested Layout: layouts in the folder hierarchy are nested, which means they wrap child layouts via their children prop.
Nested Routes: ability to create a hierarchical structure of pages that reflects a path hierarchy in the URL.
  - just pile up the folders and don't forget the file page.tsx.
Next.js: React-based framework for building web applications. React, in turn, can be considered a library for building user interfaces.
  - it takes care of Routing, Optimized Rendering, Data Fetching, Bundling, Compiling, Authentication, Deploy, Caching, Styling.
.next folder: build output directory that keeps static files and is automatically generated when you build or start your Next.js application.
  - within the /server we have an /app corresponding to the router
  - each static generated route is in this folder, and there is a .rsc respective file with the RSC payload
NextRequest: extends the Request Web Request API with additional convenience methods.
  - with request.nextUrl.searchParams we can access all query parameters.
  - check Request
Not Found Page: 404 not found page when the next router doesn't find any match, or programatically with notFound() function.
  - you customize the Not Found Page creating a not-found.tsx file.
  - it creates an ErrorBoundary.
not-found.tsx: file responsible for the customization of the Not Found Pages.
notFound(): function that calls the Not Found Page.
no-store: cache option to opt out of caching for individual data fetches.
  - const response = await fetch("http://...", {cache: "no-store"})
  - after you place a no-store fetch request, all subsequent fetches will also have no cache.
  - place all fetch requests that you want to cache before a fetch with no-store set.
  - an alternative is to configure a route level configuration
    - export const fetchCache = "default-cache"; route segment configuration
  - by default Next will cache fetch requests that occur before any dynamic functions like cookies(), headers(), searchParams are used.
  - it will not cache requests found after dynamic functions.
Optional Catch-all Segments: like catch all segments but will also match the original route;
  - use double square brackets [[..segmentName]].
page.tsx: special file that is unique to a route allows you to create UI for it.
  - put page.tsx exporting some component as default.
Page Routes: the way pages are mapped to URLs using the filesystem-based routing system. They usually serve HTML code, instead of json or other types returned by APIs like RESTful.
  - Page Routes and Route Handlers may conflict, in this case the route.ts always prevail. Avoid these situations by ading /api to the URL path, for instance.
Parallel Routes: advanced routing mechanism that uses Slots and allows for the simultaneous rendering of multiple pages within URL path using the same layout.
  - useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.
  - you can have routes inside slots and this brings Unmatched Routes in other slots specially on page reloads. Treat it with default.tsx.
  - each slot works independently like Concurrent Rendering.
  - you can also use Conditional Rendering with Slots, just treat them as normal components.
  Unmatched Routes: they may happen if we navigate using the URL directly. Some slots may have the URL and others don't. Using <Link> this problem simply doesn't happen.
    - to solve this problem, we may define @slot/default.tsx files for the slots that don't have the URL defined.
  Slots: used in Parallel Routes, they are pieces of UI that do not represent routes and are defined with the @folder convention.
    - they allow you to define named sections inside a layout where independent UI components (routes) can be rendered.
    - if you try to access them via route, you'll get a 404.
    - each slot allows for Independent Route Handling. each slot allows for Sub-navigation, that is, they function as a mini-application.
    - you can place routes inside a slot folder, in that case, when accessing via <Link/> the rest of the slots will stay with current state.
    - if you access a slot inside a route refreshing the page, all non defined slots will fallback on a default.tsx, or throw a 404 if any of them don't have one.
  @slot/default.tsx: serves as a fallback component for a slot when a matching segment isn’t provided. It ensures that the UI doesn't break or return a 404 when a slot is missing when the url is accessed directly.
params: props used to capture the value of dynamic segments as key-value pairs.
  - promise that resolves to an object containing the dynamic route parameters (like id).
    - params are used in dynamic routes, and usually dynamic routes fetch things and may take a while, that's why we use Promises.
  - it is passed as prop to layout, page, route, and generateMetadata functions.
  - for query parameters, check searchParams.
  - usually it is seen together with params.
  - to use in server components, use async await. To use in client components, use use() hook.
PATCH(): put this function inside a route.ts file to handle a PATCH request.
  - you can respond the request with return Response.json(...) or with return NextResponse.json({data})
  - export async function PATCH(_request: Request, {params}) {...}
POST(request): put this function inside a route.ts file to handle a post request.
  - use request parameter to access request body.
Postcss: tool for transforming CSS with JavaScript.
Prefetching: when a <Link /> component enters the user's viewport (initially or through scroll) Next.js prefetches and loads the linked route (denoted by the href) and data in the background to improve the performance of client-side navigations.
  - technique used to preload a route in the background before the user navigates to it.
Private Folder: indicate that it is a private implementation and should not be considered by the routing system.
  - prefix the folder name with an underscore _. The folder and all its subfolders are excluded from routing.
  - as an alternative, you can use colocation to place files in the folder of the routes, or place the files outside of the app/ folder.
  eg: you can put utility functions like format date
Production Server: optimized build is created once, and you deploy that build.
  - pages are pre-rendered once when we run build command.
redirect(): function that redirect the user to another URL.
  - can be used in Server Components, Route Handlers, and Server Actions.
  - you can use redirects with Route Handlers, Middlewares and next.config.js.
  - for permanent redirects it returns a 301 code. For temporary redirects it returns a 307 code.
Rendering: process that transforms the code you write into user interfaces.
  - CSS, SSR, RSC: choosing the right time and place to render is vital.
Request: interface of the Fetch API representing a resource request
  - it has the Request type and lots of methods to return
  - in Next, it is preferable to use the NextRequest since it provides extra methods.
Request Headers: metadata sent by the client
  - 'User-Agent': identifies the browser and operating system. Useful for specific renderings and analytics.
  - 'Accept': indicates content types the Client can process. The server has the option to respond with one of these.
  - 'Authorization': header used by the client to authenticate itself to the server.
Request Memoization: type of cache that extends the fetch API to automatically memoize requests that have the same URL and options.
  - in a Component Tree, you don't need to fetch data at the top of the tree and forward props to optimize.
  - while Data Cache is a cache that works accross different renderings, Request Memoization works in the same rendering.
  - it is a React feature, not a Next.Js feature.
  - it is used to dedupe requests using React.cache.
  - only applies to GET method in fetch requests.
  - only applies within React Component Tree. Does not extend to fetch requests in Route Handlers.
reset(): an error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the Error boundary's contents.
  - the cause of an error can sometimes be temporary. In these cases, simply trying again might resolve the issue.
Response(): interface of the Fetch API represents the response to a request.
  - check Response() in javascript glossary.
  - there is a better alternative with NextResponse which provide additional convenience methods.
  - if you want to respond with code, pass a second object parameter with headers and status fields. Check documentation.
  - the second argument is the headers object, check documentation if you want to change "Content-Type" to text/html, for instance.
Response Headers: metadata sent back from the server to the client.
  - 'Content-Type': header that indicates the media type of the response. eg: text/html, application/json, etc.
Revalidation: process of purging the Data Cache and re-fetching the latest data.
Root Layout: defined at the top level of the app directory and applies to all routes.
  - you can't get rid of this layout file. If you delete, it will reappear.
  - besides a normal Layout, it must contain html and body tags.
Route Group: organize your route segments and project files into logical groups without affecting the URL path structure.
  - wrap a folder's name in parenthesis: (folderName). the name in the parenthesis won't be part of the url, and act as an organization folder.
  - you can use layout files specific to the route group.
Route Group Layout: help in organizing related routes together. Also apply a layout to pages grouped by a Route Group.
  - you can create a specific rout group named (with-specific-layout).
  - just divide all the routes in Route Groups, and for each Route Group use a different root layout.
Route Handlers: allow you to create custom request handlers (eg: RESTful endpoints) for a given route using the Web Request and Response APIs. Unlike Page Routes, which give us HTML.
  - use the file route.ts instead of page.tsx in the App folder.
  - while page routes respond with html, route handlers allow you to create RESTful endpoints and respond with json, for instance.
  - you don't need to create and configure a separate server! no need to express.js, They run on server-side, can access databases, etc. While page routes are router in the frontend, route handlers are routing in the backend.
  - keep in mind that behind the scene, Next uses web APIs developed in Node.js and similar to Express.js.
  - supports: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS.
  - Page Routes and Route Handlers may conflict, in this case the route.ts always prevail. Avoid these situations by ading /api to the URL path, for instance.
Route Segment Configuration: allows you to configure the behavior of a Page, Layout or Route Handler  by directly exporting variables.
  - configuration variables that can be exported:
    - dynamic: 'auto' | 'force-dynamic' | 'error' | 'force-static'
    - dynamicParams: boolean
    - revalidate: false | 0 | number
    - fetchCache: 'auto' | 'default-cache' | 'only-cache' | 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'
      - should only be used if you specifically need to override the default behavior.
    - runtime: 'nodejs' | 'edge'
    - preferredRegion: 'auto' | 'global' | 'home' | string | string[]
    - maxDuration: number
Route Types
  - Simple Routes: /about
  - Nested Routes: /info/about
  - Dynamic Routes: /artists/32
  - Nested Dynamic Routes: /artists/12/album/14
  - Catch-all Segments: /a/b/c/123 ou /en/article1
route.ts: file responsible for route handlers.
  - export async function GET() {return Response.json({ message: 'Hello - GET' });}
  - If there are page.ts and route.ts files in the same folder, page.ts takes precedence.
Routing: process of determining how an application or system directs a request to the appropriate destination.
  - it defines how requests to specific URLs are mapped to web pages and resources. eg: a POST request to /products would trigger a specific server function return a json resource.
  - the routing to some address could provide different responses depending on the user agent info.
  - Next.js uses a file-system based routing mechanism.
    1 All routes must live inside the app folder.
    2 Route files must be named either page.js or page.tsx
    3 Each folder represents a segment of the URL path.
  - Next has its own backend functionalities known as API Routes.
RSC Architecture: start using Client Components and Server Components in React.
  - it is an advance in rendering. CSR -> SSR -> SSR with Suspense -> RSC
  - now, instead of treat everything like Client Components, we can also choose what will be rendered only on the server and be kept out of any js bundle (even if splitted with Suspense), or any hydration process (even selective hydration).
RSC Loading Sequence
RSC payload: serialized data sent from the server to the client when using React Server Components.
  - they contain: Serialized React elements and components, Server-rendered data (fetches results), References to client components.
  - data and components that are pre-rendered on the server and sent to the client to hydrate the application.
  - the payload is a binary containing
    - the rendered HTML in the server.
    - metadata about the structure of the component tree to update the browser's DOM.
    - any props from the Server Components to the Client Components (integration).
  - the RSC payload passes from React, to Next and then to the Browser.
  - comprises of pre-rendered HTML, Component State, Props and JavaScript Code.
  - we can find .rsc files in /.next/App related to each route, with a json string representing the virtual DOM.
  - for a Server Component we can even find the rendered html in this .rsc json file.
  - for Client Component the payload includes placeholders (instructions) about where the components should be rendered along with references to the js files.
  - we can find some of the js code related to components in /static/chunks/app/...
RSC Update Sequence
searchParams: promise that resolves to an object containing the query parameters.
  - usually it is seen together with params.
  - to use in server components, use async await. To use in client components, use use() hook.
Selective Hydration: allows for the hydration of sections as they become available, before the rest of the HTML and the JavaScript code are fully downloaded.
  - check Code Splitting.
  - eg: const MainContent = lazy(() => import('./MainContent.js'));
Server Action: asynchronous functions that are executed on the server.
  - place the directive "use server" at the top of an async function.
  - check react:Server Actions
Server Components: allow for rendering UI on the server.
  - they can access the server. but they can't use hooks, event listeners, manage state, access browser APIs, handle user interaction.
  - server components can be async and fetch data directly without useEffect.
  - advantages: zero bundle size, direct access to server-side resources, improved security, better SEO.
server-only: module that provides a build-time error if developers accidentaly import a module that should stay in the server into a Client Component.
  - to enable it, all you have to do is import "server-only" after installing it.
Server-Side Rendering (SSR): consists of rendering the components on the Server. The client makes a request, HTML is generated on the server and sent. Then JS is sent to the client to hydrate the HTML sent by the server, that is, to turn raw HTML into interactive UI.
  - the server generate HTML and returns to the Client full HTML+JS reference translating into a non-interactive UI.
  - sometimes SSR is confused with Server-Side Solutions, which encompasses both SSG and SSR.
  - improves SEO
  - users can immediately see the page HTML content instead of a blank screen or loading spinner. Then it requests the referenced JS bundle and when it returns we'll have a full interactive page, this process is called hydration.
  - it is a kind of Server-side solution
  drawbacks
    - Data fetching must be completed before the server can begin rendering HTML. (solve Streaming (Suspense))
    - The JavaScript required for the components needs to be fully loaded on the client side before the hydration process can start. (Solve with Selective Hydration (Suspense))
    - All components have to be hydrated before they become interactive. (Solve with Selective Hydration (Suspense)).
  - Server Rendering Strategies
    - Static Rendering - SSG.
    - Dynamic Rendering - SSR.
    - Streaming - SSR with Suspense.
  - while SSG generates all the HTML at once at build time since the HTML is the same for all visitors, SSR renders page on-demand, where the HTML depends for instance on who's logged in.
Server-Side Solutions: both Static Site Generation (SSG) and Server-Side Rendering(SSR) are Server-Side Solutions.
Static Content: rendered as a hollow circle. Route pre-rendered at build time as static content.
Static Metadata File: defines metadata in form an object that can be placed in Pages and Layouts.
  - eg: export const metadata = {title: "Next.js", description: "Generated by Next.js"}
Static Rendering: server rendering strategy where we generate HTML pages at the time of building our application.
  - we can build the page once, cache it in a CDN, and serve it to the client almost instantly.
  - static rendering is the default rendering strategy in the app router.
  - all routes are automatically prepared at build time without additional step.
  - for Static Routes, the entire route is prefetched and cached by default.
  - I believe it is the same thing, or uses, SSG.
Static Page: webpage that is pre-rendered at build time and served as-is to the user without requiring further processing on the server or client-side such as database consultations.
  - typically generated using Static Site Generation (SSG), a technique that creates HTML files for each page at build time.
Static-Site Generation (SSG): occurs at build time, when the application is deployed on the server.
  - ideal for content that doesn't change often, like blog posts.
  - it is a kind of Server-side solution.
Streaming: another Server Side rendering strategy that allows for progressive UI rendering from the server.
  - it is a Next concept but relies on the Suspense concept from React.
  - divide the work in chunks and stream it to the client as soon as it's ready.
  - enables users to see parts of the page immediately, before the entire content has finished rendering.
  - check HTTP Streaming.
  - to use it, import Suspense from React and Wrap objects that you want to use it.
  - don't forget to pass a fallback component.
Sub-navigation: inside a slot, you can navigate to a different slot, without reloading the whole page.
Suspense: allows you to wait for some code or data to load before rendering a component.
  - React doesn't have to wait for the code inside the Suspense component to render the rest of the page. The code for the Suspense is fed later (HTML streaming).
  - used to handle scenarios where you have asynchronous operations, such as data fetching or code splitting, and you want to provide a fallback UI while waiting for the data or code to become available.
  - HTML streaming on the server.
  - selective hydration on the client.
Template: similar but different from Layout. When a user navigates between routes that share a template, a new instance of the component is mounted.
  - DOM elements are recreated, state is not preserved, effects are re-synchronized.
  - while with Layouts the objects persist, with Templates you get fresh instances of a structure.
  - to use a template it's similar to layout, but use a template.tsx file.
template.tsx: name of the file to declare a template.
Time Based Data Revalidation: automatically revalidates data after a certain amount of time has passed.
  - is a middle ground between caching and no-caching.
  - to revalidate data at a timed interval, use the next option fetch to set the lifetime of the resource in seconds.
  - const response = await fetch("...", {next: {revalidate: 10}})
  - for pages, you can set the revalidate route segment configuration to establish the default revalidation time with:
  - export const revalidate = 10;
  - the lowest revalidate time across each layout and page of a single route will determine the revalidation frequency of the entire route.
title metadata: define the document title. It can be passed as a string in the key-value pair of the metadata, or as an object.
  - the object version has 3 keys: absolute, default and template.
  default: provides a default title to child elements that don't explicity specify a title.
  template: act as a layout for children pages.
  absolute: will ignore any template title set in parents.
Unmatched Routes: when slots have subroutes inside them, sibling slot may not have the same route.
URL Query Parameters: pass parameters to the request using ?query= notation in the URL
  - eg: localhost:3000/comments?query=first
  - with request.nextUrl.searchParams we can access all query parameters.
  - usually is used to filtering requests.
Web Vitals: initiative created by Google to provide unified guidance and metrics to measure end-user page experience on the web.

================================================================================
Hooks

usePathname(): hook provided by Next.js that supplies the current route name (url after the domain).
  - it is useful to check which <Link> is active to give proper styling. also useful for breadcrumbs.
  eg: if you just want to access the values of nested dynamic routes, you could also use nested dynamic routes.
  eg: for http://localhost:3000/forgot-password the path would be /forgot-password
useRouter(): hook that allows you to access the router object inside any function component in your app. It allows you to navigate programatically instead of using links.
  - with the router object, you can navigate Programatically.
  - router.push(/): handles client-side transitions.
  - router.replace(): prevent adding a new URL entry into the history stack.
  - router.back(): navigate back in history.
  - router.reload(): reload the current URL.

================================================================================
Modules

next/app - Used for defining the root application layout and logic (e.g., AppRouter components).
next/auth (if using next-auth) - Handles authentication and session management.
next/cache - Cache helpers for server-side rendering.
next/config - Access runtime configuration defined in next.config.js.
next/constants - Access shared constants (e.g., environment detection).
next/data - (For App Router) Used for fetching server-side or static data.
next/fetch - Enhanced fetch API for App Router.
next/font - Handles custom and Google Fonts with automatic optimization.
next/head - Allows you to modify the <head> of a page (e.g., for metadata, title, and meta tags).
next/headers - Manage request and response headers in App Router.
next/image - Offers optimized image rendering with lazy loading and resizing.
next/layouts - Handles layouts in the App Router.
next/link - Enables client-side navigation between routes.
next/middleware - Specific to middleware creation.
next/navigation - Provides client-side navigation utilities
  eg: useRouter(), usePathname(), useSearchParams(), notFound() redirect()
next/router (for legacy routing) - Access the router instance and manage navigation programmatically.
next/script - Optimizes the loading of third-party scripts.
next/server - Provides utilities for middleware and server-side features. (NextRequest, NextResponse)

================================================================================
tools and libs

turbopack: bundler designed to replace tools like Webpack for modern JavaScript and web development.
  - It is developed by the creators of Webpack and is optimized for performance and scalability.
  - Turbopack is used to bundle and optimize JavaScript, TypeScript, CSS, and other web assets for both development and production.