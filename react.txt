- every time you see a repeating pattern, that is a candidate for a component.
- you should think carefully about component granularity.

================================================================================
React Glossary

Children: props.children holds the subcomponents that are nested inside the component definition.
  - they are hold in array form.
  - if you want more clarity, readibility and flexibility, use Children, as an alternative, if you want more control, pass the subcomponents as props.
Class Components: way to define components. They are ES6 classes that extend from React.Component and have a render() method that returns JSX.
  - you can add state via this.state.
  - they have lifecycle methods like componentDidMount(), componentDidUpdate(prevProps, prevState), componentWillUnmount().
className: prop used to specify a CSS class for an element.
  - class is a reserved word in JavaScript.
Component: independent chunks of user interfaces.
  - you can have independent, isolated and reusable elements.
componentDidMount(): lifecycle method called after the component is mounted.
  - used for performing side-effects such as fetching data.
constructor(props): called before the component is mounted and used for initializing state and binding methods.
Controlled Component: when there is feedback, you change the input value, which is a state, and the component updates the state, which controls the value.
  - eg: <input value={input} onChange={(e) => setInput(e.target.value)} />
Core Content Components: primarily focused on displaying the main content and functionality of your application.
  - unlike layout components, which handle the overall structure and layout, core content components deal with the specific data, logic, and presentation of your application's content.
  - eg: article, UserProfile, ProductList, CommentForm.
createRoot(domNode): create a React root for displaying content inside a browser DOM element.
  - import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Greeting />);
  - import { createRoot } from 'react-dom/client'; const domNode = document.getElementById('root'); const root = createRoot(domNode); root.render(<App />);
  - probably this is the moment that Virtual DOM is created.
Declarative Programming: you describe what each part of your UI should look like and React takes care of rendering the UI accordingly.
Diffing: concept of comparing the virtual DOMs before and after the modification and ensuring efficient updates.
  - aka: DOM Diffing
Error Boundary: special component that lets you display some fallback UI instead of the part that crashed.
  - by default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an error boundary.
<Fragment>: often used via <>...</> syntax, lets you group elements without a wrapper node.
Higher-Order Component: function that takes a component and returns a new component.
JSX: a syntax extension for JavaScript, often used with React to describe what the UI should look like.
  - lets you write HTML-like code in your JavaScript files.
  - stands for JavaScript XML.
Layout Components: specialized components that focus on organizing other components within a web page.
  - eg: split screen, lists, modals.
Lifecycle Methods: special methods that get called at different stages of a component's lifecycle.
One-way data flow: parent components pass data to their children via props, and children communicate back to parents only through callbacks.
<Profiler>: lets you measure rendering performance of a React tree programmatically.
Props(react-ts-snippets.md#props): short for "property" is way of passing data from a parent component to a child component.
  - Props are immutable, that is, a component cannot change its own props.
  - they allow you to customize and configure the behavior and appearance of child components.
  - usually you receive a prop argument and use prop.argX... but it is more common to see the prop object being destructured.
React: a javascript library for building user interfaces.
render(): required lifecycle method in a class component that returns the React elements to be rendered to the DOM.
Reconciliation: compares the actual Virtual DOM with the previous one to calculate the minimal set of changes needed to update the actual DOM.
  - it significantly improves performance compared to directly manipulating the DOM.
Request Memoization: type of cache that extends the fetch API to automatically memoize requests that have the same URL and options.
  - in a Component Tree, you don't need to fetch data at the top of the tree and forward props to optimize.
  - while Data Cache is a cache that works accross different renderings, Request Memoization works in the same rendering.
  - it is a React feature, not a Next.Js feature.
  - it is used to dedupe requests using React.cache.
  - only applies to GET method in fetch requests.
  - only applies within React Component Tree. Does not extend to fetch requests in Route Handlers.
Route Component
<StrictMode>: lets you find common bugs in your components early during development.
  - Your components will re-render an extra time to find bugs caused by impure rendering.
  - Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
  - Your components will be checked for usage of deprecated APIs.
<Suspense>: lets you display a fallback until its children have finished loading.
'use client': lets you mark what code runs on the client.
  - will treat the module import as a boundary between server-run and client-run code.
  - the dependencies will also be evaluated on the client regardless of whether their modules contain a 'use client' directive.
useEffect(): hook that lets you synchronize a component with an external system.
useState(): hook that lets you add a state variable to your component.
  - const [state, setState] = useState(initialState)
Virtual DOM: virtual representation of the actual DOM. When the state of a component changes, React creates a new Virtual DOM representation and then proceeds to perform a Reconciliation.
  - VDOM