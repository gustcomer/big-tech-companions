- every time you see a repeating pattern, that is a candidate for a component.
- you should think carefully about component granularity.

================================================================================
React Glossary

{}: curly braces are a feature of JSX that allows to embed JavaScript expressions within the markup.
  - It allows you to incorporate logic and data into your JSX.
Binding Event Handlers: there are four approaches to bind event handlers
  - [1] bind this to the function on onClick={this.clickHandler.bind(this)}, but this is not optimal to bind at every rerender.
  - [2] use arrow function right on the onClick={() => this.clickHandler()}, but this is also not optimal.
  - [3] define a handler method clickHandler and bind it in the constructor with this.clickHandler = this.clickHandler.bind(this).
  - [4] define the handler method as class property with arrow function clickHandler = () => {...} since in arrow functions the this keyword always represents the object that defined the arrow function, that means that are no binding of this.
Children: props.children holds the subcomponents that are nested inside the component definition.
  - they are hold in array form.
  - if you want more clarity, readibility and flexibility, use Children, as an alternative, if you want more control, pass the subcomponents as props.
  - to render the children, simply state {props.children} in the return statement of the component.
Class Components: way to define components.
  - they are ES6 classes that [1] extend from React.Component and [2] have a render() method that returns JSX.
  - you can add state via this.state.
  - they have lifecycle methods like componentDidMount(), componentDidUpdate(prevProps, prevState), componentWillUnmount().
  - they used to be called Stateful Class Component.
className: prop used to specify a CSS class for an element.
  - class is a reserved word in JavaScript.
Component: modular, reusable and independently deployable pieces of code.
  - eg: pieces of UI in React. Each microservice.
Component: independent chunks of user interfaces.
  - in React, it represents a part of the user interface.
  - you can have independent, isolated and reusable elements.
Component-Based Architecture: decompose a system into Components.
componentDidMount(): lifecycle method called after the component is mounted.
  - used for performing side-effects such as fetching data.
Compound Component: design pattern that involves creating a parent component that maintains the state and provides context, and several child components that work together under this parent component.
  - the Child components are kept under the same file and are named MainComponent.ChildComponent preferably with the dot.
  - the state is passed to the child components via context and accessed with useContext, and not via props.
Conditional Rendering:
  - there are 4 methods [1] if/else [2] element variables [3] ternary conditional operators [4] short circuit operators.
  [1] if/else: remember that you can't put ifs and elses inside a return statement
    if (state.isLoggedIn) { return <div>Welcome {user}</div> } else { return <div>Welcome Guest</div>  }
  [2] element variables: conditionally store JSX in javascript variables and return the message
    if (state.isLoggedIn) { msg = <div>Welcome {user}</div> } else { msg = <div>Welcome Guest</div> } | return message; or return <div>{message}</div>
  [3] ternary conditional operator: return statements do support ternary conditional operators
    return state.isLoggedIn ? ( <div>Welcome {user}</div> ) : ( return <div>Welcome Guest</div> )
  [4] short circuit operator: it's just syntactic sufar for ifs conditions
    return state.isLoggedIn && <div>Welcome Vishwas</div>
constructor(props): called before the component is mounted and used for initializing state and binding methods.
Controlled Component: form elements (like <input>, <textarea>, and <select>) whose values are controlled by the React state. This way these element values will stay in sync with the component's state.
  - the form element's value is set via a React prop passing some state. <input type="text" value={this.state.inputValue} ... />
  - An onChange event handler is used to update the component's state when the user interacts with the form element. <input type="text" ... onChange={this.handleChange} />.
  - the handler method could be handleChange = (event) => { this.setState({ inputValue: event.target.value }); } Don't forget to bind 'this' or use arrow that automatically binds.
  - in essence, there are 3 steps [1] add the HTML element [2] add state and connect to the input value [3] add onChange and handle method.
  - there is a cycle of setting the initial value of the input field from the Component's state, the propagating changes to the input value to the state with onChange and then back to the field.
  - when there is feedback, you change the input value, which is a state, and the component updates the state, which controls the value.
  - eg: <input value={input} onChange={(e) => setInput(e.target.value)} />
Core Content Components: primarily focused on displaying the main content and functionality of your application.
  - unlike layout components, which handle the overall structure and layout, core content components deal with the specific data, logic, and presentation of your application's content.
  - eg: article, UserProfile, ProductList, CommentForm.
createRoot(domNode): create a React root for displaying content inside a browser DOM element.
  - import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Greeting />);
  - import { createRoot } from 'react-dom/client'; const domNode = document.getElementById('root'); const root = createRoot(domNode); root.render(<App />);
  - probably this is the moment that Virtual DOM is created.
  - ReactDOM.createRoot(..) replaced ReactDOM.render(..).
Data Flow: in React, data flows in a unidirectional manner from parent to child components.
  - props are used to pass data from a parent component to a child component.
  - state is a way to manage data that can change over time within a component. Obviously, you can pass a state down the component tree as a prop.
  - if more than one component need to share state, lift the state up to the nearest common ancestor and pass the state down to its children via props.
  - you can avoid props drilling and pass data (states) through the component tree using Context API. It's usefull for global data such as user authentication, themes, etc.
  - since props are immutable, if you need children to communicate with parents, you need to pass methods from the parent to the child component. Don't forget to bind the 'this' context.
    - <button onClick={props.handler}>Call Handler</button> -- add this code in the child component
  - if you want the child compnent to pass parameters to the parent, add parameters to the handler and in the child component transform it into an arrow function with parameters.
    - <button onClick={() => props.handler('child')}>Call Handler</button>
Declarative Paradigm: style of programming where the focus is on what the program should accomplish rather than how it should accomplish it.
  - contrasts with imperative programming where you write explicit instructions on how to perform tasks.
  - eg: React, SQL, HTML, CSS, Functional Programming Languages like Haskell or Lisp.
Declarative Programming: you describe what each part of your UI should look like and React takes care of rendering the UI accordingly.
Destructuring: allows you to extract values from arrays or properties from Objects. In React, you can use them to extract values from props.
  - in FC, you extract them in the functions parameter. In CC, you extract them in the render() method with const {a, b} = this.props
Diffing: concept of comparing the virtual DOMs before and after the modification and ensuring efficient updates.
  - aka: DOM Diffing
Error Boundary: special component that lets you display some fallback UI instead of the part that crashed.
  - by default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an error boundary.
Event Handling: events occur, at least, every time a user interacts with the UI.
  - eg: mouse clicks, mouse overs, key press, change event, so on.
  - in JSX, events are camel cased eg: onClick. in html they are lower case: onclick.
  - in JSX, you pass the handler in curly braces without parenthesis (otherwise it becomes a function call): onClick={clickHandler}. in html you pass as a string: onclick="clickhandler()".
<Fragment>: often used via <>...</> syntax, lets you group elements without a wrapper node.
Higher-Order Component: function that takes a component and returns a new component.
  - it's a technique for reusing component logic.
  - HOCs are used to add additional functionality to a component without modifying it directly.
  - they are very similar to Decorator Pattern since they add functionality without modifying, and kinda favor composition over inheritance.
  - commonly used for cross-cutting concerns like authentication, state management and performance optimization.
  - both HOCs and Render Props are used for sharing logic and functionality between components.
  - use HOCs when the code involves states and other functions, use Render Props when the code you share is more related to pure JSX.
JSX: a syntax extension for JavaScript, often used with React to describe what the UI should look like.
  - lets you write HTML-like code in your JavaScript files.
  - stands for JavaScript XML.
  - at the end of the day, JSX is just synctatic sugar for function calls and objects construction.
  - JSX tags have a tag name, attributes and children.
  - the alternative to JSX was the React.createElement(..) function.
    - the first element is the html component name, the second are optionals and the third is the children.
  - usually we import React from 'react' to be able to use JSX.
  - JSX differences: Class -> className; for -> htmlFor; camelCase property naming convention.
  - {} curly braces are a feature of JSX that allows to embed JavaScript expressions within the markup. It allows you to incorporate logic and data into your JSX.
  - in JSX, events are camel cased eg: onClick. in html they are lower case: onclick.
key prop: each child in an array or iterator should have a unique "key" prop of the type string.
  - each item in the list rendered using the map operator should have it.
  - funny thing, in the child components, this key prop will not be accessible. It is reserved.
  - it is useful when iserting new items at the top of the list, since it will only need to mutate the first element and not the entire list.
  - keys give the elements a stable identity.
  - you could use the index (supplied by the map function as the second parameter) as key, but that's very stupid if you need to insert elements at the top of this list.
  - you could use the map index as key, if the list were static (never changed) and also never reordered or filtered.
Layout Components: specialized components that focus on organizing other components within a web page.
  - eg: split screen, lists, modals.
Lifecycle Methods: special methods that get called at different stages of a component's lifecycle and can be overwritten. They are available for Class Components.
  - useEffect hook partially accomplishes what lifecycle methods do.
  - the methods can be classified in 4 phases 
    [1] Mounting: when an instance of a component is being created and inserted into the DOM.
      - constructor, getDerivedStateFromProps(), render and componentDidMount()
    [2] Updating: when a component is being re-rendered as a result of changes to either its props or state.
      - getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate() and componentDidUpdate()
    [3] Unmounting: when a component is being removed from the DOM.
      - componentWillUnmount()
    [4] Error Handling: when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.
      - getDerivedStateFromError() and componentDidCatch()
List Rendering: you can render lists by using map in the JSX but using {} to allow javascript expressions inside the JSX.
  - return (<div>{names.map(name => <h2>{name}</h2>)}</div>); or yet const nameList = names.map(name => <h2>{name}</h2>);
  - when you use map, each element in the map should have a unique "key" prop.
One-way data flow: parent components pass data to their children via props, and children communicate back to parents only through callbacks.
<Profiler>: lets you measure rendering performance of a React tree programmatically.
Props(react-ts-snippets.md#props): short for "property" is way of passing data from a parent component to a child component.
  - Props are immutable, that is, a component cannot change its own props.
  - they allow you to customize and configure the behavior and appearance of child components.
  - usually you receive a prop argument and use prop.argX... but it is more common to see the prop object being destructured.
  - if you don't know what you're gonne need to render, but want to render it anyway, pass it as children inside the open and closing tags of the component.
  - in Class Components the props are available through this.props. While in functional components you pass it through props parameter.
Props Drilling: process of passing data from a parent component to a deeply nested child component through multiple layers of intermediate components.
  - you can solve this issue using Context API or State Management Libraries like Redux, MobX, Recoil.
React: a javascript library for building user interfaces.
React.FC: [ts] type of Functional Components.
React.JSX.Element: [ts] type of single React Element.
React.ReactNode: [ts] type of everything React can render.
reducer: function that determines actions in an application imply in changes to an application's state.
  - in other words, it decouples Updates (how the states change) from Actions.
  - it is usually a pure function that is key to state management libraries like Redux.
  - function counterReducer(state, action) { switch action.type ... return newState }.
  - in FC you can useReducer via const [state, dispatch] = useReducer(reducer, initialState);
  - the state is decoupled from actions because to change the application's state you simply call dispatch({ type: 'tick' });
render(): required lifecycle method in a class component that returns the React elements to be rendered to the DOM.
Render Props: technique where a component accepts a function as a prop and uses that function to determine what to render.
  - use Render Props when the code you share is more related to JSX and does not involve states and other functions.
Reconciliation: compares the actual Virtual DOM with the previous one to calculate the minimal set of changes needed to update the actual DOM.
  - it significantly improves performance compared to directly manipulating the DOM.
Request Memoization: type of cache that extends the fetch API to automatically memoize requests that have the same URL and options.
  - in a Component Tree, you don't need to fetch data at the top of the tree and forward props to optimize.
  - while Data Cache is a cache that works accross different renderings, Request Memoization works in the same rendering.
  - it is a React feature, not a Next.Js feature.
  - it is used to dedupe requests using React.cache.
  - only applies to GET method in fetch requests.
  - only applies within React Component Tree. Does not extend to fetch requests in Route Handlers.
root DOM node: a div with id="root" that React takes control and starts rendering stuff.
Route Component
serviceWorker: related to Progressive Web Apps (PWA).
State: stores dynamic data about a component.
  - it can be accessed through this.state in Class Components. In Functional Components it is accessed with useState(..) hook.
  - in Class Components don't update this.state directly, instead, use this.setState({...}). Else, the state is updated but not displayed in the UI.
  - the calls to setState are asynchronous! and hence, not immediately updated. If you want to execute something after the state is updated, pass the callback as the second parameter.
  - the setStates are grouped for better performance, so if you want to use multiple setState functions, pass a callback function as first parameter with prevState as parameter. This function can also have props.
State Lifting: technique used in React to manage shared state between multiple components. When two or more sibling components need to share the same state, the state is often lifted up to their closest common ancestor.
Stateless Functional Component: components declared via functions.
  - they used to have no state, but after hooks were introduced, even the functional components now can have state.
<StrictMode>: lets you find common bugs in your components early during development.
  - Your components will re-render an extra time to find bugs caused by impure rendering.
  - Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
  - Your components will be checked for usage of deprecated APIs.
Styling React Components
  [1] CSS stylesheets: in this case you simpli import the CSS and the styles will automatically be applied to the Component.
  [2] Inline Styling: just create an object with properties as keys and values as values and use style={heading} in your components.
  [3] CSS Modules: is just like the CSS stylesheets but instead of using the class names as string, you use them as properties of a style object.
    - the advantage of CSS Modules is that the class has only local scope, while in CSS stylesheets the scope is also for all of its children components and hence is more error prone.
  [4] CSS in JS Libraries
<Suspense>: lets you display a fallback until its children have finished loading.
'use client': lets you mark what code runs on the client.
  - will treat the module import as a boundary between server-run and client-run code.
  - the dependencies will also be evaluated on the client regardless of whether their modules contain a 'use client' directive.
useEffect(): hook that lets you synchronize a component with an external system.
  - it lets you perform side effects in function components and works similar to componentDidMount, componentDidUpdate, componentWillUnmount, etc.
  - side effects in this context are operations that affect something outside the scope of the function, such as data fetching, subscriptions, or manually changing the DOM.
  - the dependencies (aka deps) is the second argument to useEffect in the form of an array of dependencies. The effect will run after the initial render and again whenever any of the dependencies change.
  - if you pass an empty array [] as deps, the effect will run only once after the initial render.
  - if your effect returns a function, it is the Cleanup Function and React will run it when the component unmounts or before the effect runs again, to clean up the previous effect.
  - usually you have to deal with loading states, error states and also racing conditions of multiple asynchronous fetches.
useState(): hook that lets you add a state variable to your component.
  - const [state, setState] = useState(initialState)
Virtual DOM: virtual representation of the actual DOM. When the state of a component changes, React creates a new Virtual DOM representation and then proceeds to perform a Reconciliation.
  - VDOM

================================================================================
React Libraries

MobX: state management library that makes it simple to manage and react to the state changes in your applications.
react-scripts: is an essential part of Create React App (CRA).
Recoil: state management library for React that aims to provide a more flexible and scalable way to manage state compared to traditional solutions like Redux.
Redux: popular state management library for JavaScript applications, often used with React.
  - key concepts: Store, Actions, Reducers, Dispatch, Selectors, Middleware.
Styled Components: allows you to write CSS in javascript files (CSS in JS lib)
Zustand: small, fast, and scalable state management library that simplifies managing global state in React applications.