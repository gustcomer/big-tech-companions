- every time you see a repeating pattern, that is a candidate for a component.
- you should think carefully about component granularity.

================================================================================
React Glossary

Binding Event Handlers: there are four approaches to bind event handlers
  - [1] bind this to the function on onClick={this.clickHandler.bind(this)}, but this is not optimal to bind at every rerender.
  - [2] use arrow function right on the onClick={() => this.clickHandler()}, but this is also not optimal.
  - [3] define a handler method clickHandler and bind it in the constructor with this.clickHandler = this.clickHandler.bind(this).
  - [4] define the handler method as class property with arrow function clickHandler = () => {...} since in arrow functions the this keyword always represents the object that defined the arrow function, that means that are no binding of this.
Children: props.children holds the subcomponents that are nested inside the component definition.
  - they are hold in array form.
  - if you want more clarity, readibility and flexibility, use Children, as an alternative, if you want more control, pass the subcomponents as props.
  - to render the children, simply state {props.children} in the return statement of the component.
Class Components: way to define components.
  - they are ES6 classes that [1] extend from React.Component and [2] have a render() method that returns JSX.
  - you can add state via this.state.
  - they have lifecycle methods like componentDidMount(), componentDidUpdate(prevProps, prevState), componentWillUnmount().
  - they used to be called Stateful Class Component.
className: prop used to specify a CSS class for an element.
  - class is a reserved word in JavaScript.
Component: modular, reusable and independently deployable pieces of code.
  - eg: pieces of UI in React. Each microservice.
Component: independent chunks of user interfaces.
  - in React, it represents a part of the user interface.
  - you can have independent, isolated and reusable elements.
Component-Based Architecture: decompose a system into Components.
componentDidMount(): lifecycle method called after the component is mounted.
  - used for performing side-effects such as fetching data.
Compound Component: design pattern that involves creating a parent component that maintains the state and provides context, and several child components that work together under this parent component.
  - the Child components are kept under the same file and are named MainComponent.ChildComponent preferably with the dot.
  - the state is passed to the child components via context and accessed with useContext, and not via props.
constructor(props): called before the component is mounted and used for initializing state and binding methods.
Controlled Component: when there is feedback, you change the input value, which is a state, and the component updates the state, which controls the value.
  - eg: <input value={input} onChange={(e) => setInput(e.target.value)} />
Core Content Components: primarily focused on displaying the main content and functionality of your application.
  - unlike layout components, which handle the overall structure and layout, core content components deal with the specific data, logic, and presentation of your application's content.
  - eg: article, UserProfile, ProductList, CommentForm.
createRoot(domNode): create a React root for displaying content inside a browser DOM element.
  - import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Greeting />);
  - import { createRoot } from 'react-dom/client'; const domNode = document.getElementById('root'); const root = createRoot(domNode); root.render(<App />);
  - probably this is the moment that Virtual DOM is created.
  - ReactDOM.createRoot(..) replaced ReactDOM.render(..).
Declarative Paradigm: style of programming where the focus is on what the program should accomplish rather than how it should accomplish it.
  - contrasts with imperative programming where you write explicit instructions on how to perform tasks.
  - eg: React, SQL, HTML, CSS, Functional Programming Languages like Haskell or Lisp.
Declarative Programming: you describe what each part of your UI should look like and React takes care of rendering the UI accordingly.
Destructuring: allows you to extract values from arrays or properties from Objects. In React, you can use them to extract values from props.
  - in FC, you extract them in the functions parameter. In CC, you extract them in the render() method with const {a, b} = this.props
Diffing: concept of comparing the virtual DOMs before and after the modification and ensuring efficient updates.
  - aka: DOM Diffing
Error Boundary: special component that lets you display some fallback UI instead of the part that crashed.
  - by default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an error boundary.
Event Handling: events occur, at least, every time a user interacts with the UI.
  - eg: mouse clicks, mouse overs, key press, change event, so on.
  - in JSX, events are camel cased eg: onClick. in html they are lower case: onclick.
  - in JSX, you pass the handler in curly braces without parenthesis (otherwise it becomes a function call): onClick={clickHandler}. in html you pass as a string: onclick="clickhandler()".
<Fragment>: often used via <>...</> syntax, lets you group elements without a wrapper node.
Higher-Order Component: function that takes a component and returns a new component.
  - it's a technique for reusing component logic.
  - HOCs are used to add additional functionality to a component without modifying it directly.
  - they are very similar to Decorator Pattern since they add functionality without modifying, and kinda favor composition over inheritance.
  - commonly used for cross-cutting concerns like authentication, state management and performance optimization.
  - both HOCs and Render Props are used for sharing logic and functionality between components.
  - use HOCs when the code involves states and other functions, use Render Props when the code you share is more related to pure JSX.
JSX: a syntax extension for JavaScript, often used with React to describe what the UI should look like.
  - lets you write HTML-like code in your JavaScript files.
  - stands for JavaScript XML.
  - JSX tags have a tag name, attributes and children.
  - the alternative to JSX was the React.createElement(..) function.
    - the first element is the html component name, the second are optionals and the third is the children.
  - usually we import React from 'react' to be able to use JSX.
  - JSX differences: Class -> className; for -> htmlFor; camelCase property naming convention.
  - {} curly braces are a feature of JSX that allows to embed JavaScript expressions within the markup. It allows you to incorporate logic and data into your JSX.
  - in JSX, events are camel cased eg: onClick. in html they are lower case: onclick.
Layout Components: specialized components that focus on organizing other components within a web page.
  - eg: split screen, lists, modals.
Lifecycle Methods: special methods that get called at different stages of a component's lifecycle.
One-way data flow: parent components pass data to their children via props, and children communicate back to parents only through callbacks.
<Profiler>: lets you measure rendering performance of a React tree programmatically.
Props(react-ts-snippets.md#props): short for "property" is way of passing data from a parent component to a child component.
  - Props are immutable, that is, a component cannot change its own props.
  - they allow you to customize and configure the behavior and appearance of child components.
  - usually you receive a prop argument and use prop.argX... but it is more common to see the prop object being destructured.
  - if you don't know what you're gonne need to render, but want to render it anyway, pass it as children inside the open and closing tags of the component.
  - in Class Components the props are available through this.props. While in functional components you pass it through props parameter.
React: a javascript library for building user interfaces.
React.FC: [ts] type of Functional Components.
React.JSX.Element: [ts] type of single React Element.
React.ReactNode: [ts] type of everything React can render.
reducer: function that determines actions in an application imply in changes to an application's state.
  - in other words, it decouples Updates (how the states change) from Actions.
  - it is usually a pure function that is key to state management libraries like Redux.
  - function counterReducer(state, action) { switch action.type ... return newState }.
  - in FC you can useReducer via const [state, dispatch] = useReducer(reducer, initialState);
  - the state is decoupled from actions because to change the application's state you simply call dispatch({ type: 'tick' });
render(): required lifecycle method in a class component that returns the React elements to be rendered to the DOM.
Render Props: technique where a component accepts a function as a prop and uses that function to determine what to render.
  - use Render Props when the code you share is more related to JSX and does not involve states and other functions.
Reconciliation: compares the actual Virtual DOM with the previous one to calculate the minimal set of changes needed to update the actual DOM.
  - it significantly improves performance compared to directly manipulating the DOM.
Request Memoization: type of cache that extends the fetch API to automatically memoize requests that have the same URL and options.
  - in a Component Tree, you don't need to fetch data at the top of the tree and forward props to optimize.
  - while Data Cache is a cache that works accross different renderings, Request Memoization works in the same rendering.
  - it is a React feature, not a Next.Js feature.
  - it is used to dedupe requests using React.cache.
  - only applies to GET method in fetch requests.
  - only applies within React Component Tree. Does not extend to fetch requests in Route Handlers.
root DOM node: a div with id="root" that React takes control and starts rendering stuff.
Route Component
serviceWorker: related to Progressive Web Apps (PWA).
State: stores dynamic data about a component.
  - it can be accessed through this.state in Class Components. In Functional Components it is accessed with useState(..) hook.
  - in Class Components don't update this.state directly, instead, use this.setState({...}). Else, the state is updated but not displayed in the UI.
  - the calls to setState are asynchronous! and hence, not immediately updated. If you want to execute something after the state is updated, pass the callback as the second parameter.
  - the setStates are grouped for better performance, so if you want to use multiple setState functions, pass a callback function as first parameter with prevState as parameter. This function can also have props.
Stateless Functional Component: components declared via functions.
  - they used to have no state, but after hooks were introduced, even the functional components now can have state.
<StrictMode>: lets you find common bugs in your components early during development.
  - Your components will re-render an extra time to find bugs caused by impure rendering.
  - Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
  - Your components will be checked for usage of deprecated APIs.
<Suspense>: lets you display a fallback until its children have finished loading.
'use client': lets you mark what code runs on the client.
  - will treat the module import as a boundary between server-run and client-run code.
  - the dependencies will also be evaluated on the client regardless of whether their modules contain a 'use client' directive.
useEffect(): hook that lets you synchronize a component with an external system.
  - it lets you perform side effects in function components and works similar to componentDidMount, componentDidUpdate, componentWillUnmount, etc.
  - side effects in this context are operations that affect something outside the scope of the function, such as data fetching, subscriptions, or manually changing the DOM.
  - the dependencies (aka deps) is the second argument to useEffect in the form of an array of dependencies. The effect will run after the initial render and again whenever any of the dependencies change.
  - if you pass an empty array [] as deps, the effect will run only once after the initial render.
  - if your effect returns a function, it is the Cleanup Function and React will run it when the component unmounts or before the effect runs again, to clean up the previous effect.
  - usually you have to deal with loading states, error states and also racing conditions of multiple asynchronous fetches.
useState(): hook that lets you add a state variable to your component.
  - const [state, setState] = useState(initialState)
Virtual DOM: virtual representation of the actual DOM. When the state of a component changes, React creates a new Virtual DOM representation and then proceeds to perform a Reconciliation.
  - VDOM