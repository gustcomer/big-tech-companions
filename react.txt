- every time you see a repeating pattern, that is a candidate for a component.
- you should think carefully about component granularity.

================================================================================
React Glossary

{}: curly braces are a feature of JSX that allows to embed JavaScript expressions within the markup.
  - It allows you to incorporate logic and data into your JSX.
Binding Event Handlers: there are four approaches to bind event handlers
  - [1] bind this to the function on onClick={this.clickHandler.bind(this)}, but this is not optimal to bind at every rerender.
  - [2] use arrow function right on the onClick={() => this.clickHandler()}, but this is also not optimal.
  - [3] define a handler method clickHandler and bind it in the constructor with this.clickHandler = this.clickHandler.bind(this).
  - [4] define the handler method as class property with arrow function clickHandler = () => {...} since in arrow functions the this keyword always represents the object that defined the arrow function, that means that are no binding of this.
Children: props.children holds the subcomponents that are nested inside the component definition.
  - they are hold in array form.
  - if you want more clarity, readibility and flexibility, use Children, as an alternative, if you want more control, pass the subcomponents as props.
  - to render the children, simply state {props.children} in the return statement of the component.
Class Components: way to define components.
  - they are ES6 classes that [1] extend from React.Component and [2] have a render() method that returns JSX.
  - you can add state via this.state.
  - they have lifecycle methods like componentDidMount(), componentDidUpdate(prevProps, prevState), componentWillUnmount().
  - they used to be called Stateful Class Component.
className: prop used to specify a CSS class for an element.
  - class is a reserved word in JavaScript.
Commit Phase: all React Elements are applied to the DOM using the react-dom package.
  - the commit phase is usually very fast, but rendering can be slow.
Component: modular, reusable and independently deployable pieces of code.
  - eg: pieces of UI in React. Each microservice.
Component: independent chunks of user interfaces.
  - in React, it represents a part of the user interface.
  - you can have independent, isolated and reusable elements.
Component-Based Architecture: decompose a system into Components.
componentDidMount(): lifecycle method called after the component is mounted.
  - used for performing side-effects such as fetching data.
componentWillUnmount(): method is invoked immediately before a component is unmounted and destroyed.
  eg: cancel network requests, remove event handlers, cancel any subscriptions (like observers, sockets), invalidate timers.
  - obviously this is a bad place to call setState().
Compound Component: design pattern that involves creating a parent component that maintains the state and provides context, and several child components that work together under this parent component.
  - the Child components are kept under the same file and are named MainComponent.ChildComponent preferably with the dot.
  - the state is passed to the child components via context and accessed with useContext, and not via props.
Conditional Rendering:
  - there are 4 methods [1] if/else [2] element variables [3] ternary conditional operators [4] short circuit operators.
  [1] if/else: remember that you can't put ifs and elses inside a return statement
    if (state.isLoggedIn) { return <div>Welcome {user}</div> } else { return <div>Welcome Guest</div>  }
  [2] element variables: conditionally store JSX in javascript variables and return the message
    if (state.isLoggedIn) { msg = <div>Welcome {user}</div> } else { msg = <div>Welcome Guest</div> } | return message; or return <div>{message}</div>
  [3] ternary conditional operator: return statements do support ternary conditional operators
    return state.isLoggedIn ? ( <div>Welcome {user}</div> ) : ( return <div>Welcome Guest</div> )
  [4] short circuit operator: it's just syntactic sufar for ifs conditions
    return state.isLoggedIn && <div>Welcome Vishwas</div>
constructor(props): called whenever a new component is created but before the component is mounted.
  - used for initializing state, binding event handlers.
  - this is the only place where you can owerwrite directly this.state
  - do not cause side effects here (eg: http requests) because you only should do them after the vDOM is rendered and should be done in componentDidMount() instead.
  - don't forget to call super(props).
componentDidCatch(error, info): lifecycle method that allows a component to catch JavaScript errors anywhere in its child component tree and apply sid effects such as log those errors.
  - it is an Error Handling Phase Methods.
  - While getDerivedStateFromError is used to update the state to render a fallback UI, componentDidCatch can be used for side effects such as logging the error.
  - it does not catch errors inside event handlers, in asynchronous code or during server-side rendering.
  - usually error is an instance of Error containing the thrown error and can be used to get details about the error such as message, stack trace for debugging.
  - the info is an Object that contains additional information about the component stack at the time the error was thrown. Useful to understand the context in which the error occurred.
componentDidMount(): called immediately after a component is mounted (inserted into the actual tree) and perform side effects which are actions that require the DOM nodes to be already in place.
  - lifecycle method called only during the end of the Mounting phase called after the component is rendered (for the first time).
  - it is the place to set up event listeners since the DOM nodes are already in place.
  - if you fetch a data at the constructor and it finishes before first rendering it, the setState() will call an update on an unmounted component and it will throw errors.
  - besides, if the fetched data arrives during the rendering, the render will be interrupted and a new render will eventually be called, messing up the virtual DOM, the diffing and the whole Conciliation process.
  - so the perfect time to fetch some data is after the rendering.
componentDidUpdate(): after the component has been effectively updated, you can perform side effects taking into account previous props, previous states, actual props and states and the snapshot from getSnapshotBeforeUpdate.
  - this is one of the three lifecycle method used to perform side effects (the others are componentDidMount and componentWillUnmount).
  - don't forget to compare the previous props with the actual props to be sure that you need to re-fetch some data or some other side-effects.
  - to conditionally update, use a conditional statement comparing prevState with this.state and prevProps with this.props.
componentWillUnmount(): invoked immediately before a component is unmounted and destroyed.
  - It's a place to perform any necessary cleanup, such as canceling network requests, removing event listeners, or invalidating timers.
componentWillUpdate(): deprecated because it was used to perform side-effects right before the re-render, but you never should do that. It was replaced by getSnapshotBeforeUpdate().
  - deprecated Updating livecycle method that was called after the shouldComponentUpdate() if it returned true and before the re-rendering.
Context: provides a way to pass data through the component tree without having to pass props down manually at every level.
    [1] create the Context: const UserContext = React.createContext(); const UserProvider = UserContext.Provider; const UserConsumer = UserContext.Consumer; export {UserProvider, UserConsumer}
    [2] use the Context and provide value: <UserProvider value="Vishwas">...</UserProvider> every component and subcomponent inside the brackets will be able to use the context value.
    [3] consume the context value: kinda strange but, involve with <UserConsumer>{{var} => {return <>..JSX..</>}}</UserConsumer> in the place where you want to use. the function receives the context value as parameter and the function uses it and has to return JSX.
  - examples where it could be useful are language option, UI theme, authentication, etc.
  - you can provide default context value in the creation of the Context: const UserContext = React.createContext('Def Value'); Now there is no need to create Providers, the Producers will receive the default value if there is no Provider above in the Provider tree.
  - you can create a custom hook out of a context to simplify notation. eg: export function useA11y() { return React.useContext(Context) }
contextType: property is used to consume a context in class components in React. It allows you to assign a context to a class component, enabling you to access the context value directly via this.context.
  - useful for older React codebases that primarily use class components instead of functional components with hooks.
  - to use it, just assign the context to the contextType property of the class component. ComponentE.contextType = UserContext; outside of the component or static contextType = UserContext; inside the component definition. But this way you can consume only one context.
  - you can consume more than one Context using multiple nested Consumers, the code is a little awkward because you enclose the child function with Consumer tags but no big deal.
Controlled Component: form elements (like <input>, <textarea>, and <select>) whose values are controlled by the React state. This way these element values will stay in sync with the component's state.
  - the form element's value is set via a React prop passing some state. <input type="text" value={this.state.inputValue} ... />
  - An onChange event handler is used to update the component's state when the user interacts with the form element. <input type="text" ... onChange={this.handleChange} />.
  - the handler method could be handleChange = (event) => { this.setState({ inputValue: event.target.value }); } Don't forget to bind 'this' or use arrow that automatically binds.
  - in essence, there are 3 steps [1] add the HTML element [2] add state and connect to the input value [3] add onChange and handle method.
  - there is a cycle of setting the initial value of the input field from the Component's state, the propagating changes to the input value to the state with onChange and then back to the field.
  - when there is feedback, you change the input value, which is a state, and the component updates the state, which controls the value.
  - eg: <input value={input} onChange={(e) => setInput(e.target.value)} />
  - to set initial values you use the initial value of the state, instead of the initial value of the defaultValue or defaultChecked attributes of the html input elements in the case of Uncontrolled Components.
  - use them in more complex applications where form state management, validation, and dynamic behaviors are necessary
Core Content Components: primarily focused on displaying the main content and functionality of your application.
  - unlike layout components, which handle the overall structure and layout, core content components deal with the specific data, logic, and presentation of your application's content.
  - eg: article, UserProfile, ProductList, CommentForm.
createRoot(domNode): create a React root for displaying content inside a browser DOM element.
  - import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Greeting />);
  - import { createRoot } from 'react-dom/client'; const domNode = document.getElementById('root'); const root = createRoot(domNode); root.render(<App />);
  - probably this is the moment that Virtual DOM is created.
  - ReactDOM.createRoot(..) replaced ReactDOM.render(..).
Custom Hooks: allow you to extract component logic into reusable functions.
  - it is basically a JavaScript function whose name starts with 'use' and can also call other built-in hooks if required.
  - hooks help you to share logic and are to functional components as HOCs and render props are to class components.
  eg: for a counter hook, instead of allowing the user to access setState which doesn't have any business logic, make a useCounter hook and returns the counter and increment, decrement and reset methods, since these are business related.
Data Flow: in React, data flows in a unidirectional manner from parent to child components.
  - props are used to pass data from a parent component to a child component.
  - state is a way to manage data that can change over time within a component. Obviously, you can pass a state down the component tree as a prop.
  - if more than one component need to share state, lift the state up to the nearest common ancestor and pass the state down to its children via props.
  - you can avoid props drilling and pass data (states) through the component tree using Context API. It's usefull for global data such as user authentication, themes, etc.
  - since props are immutable, if you need children to communicate with parents, you need to pass methods from the parent to the child component. Don't forget to bind the 'this' context.
    - <button onClick={props.handler}>Call Handler</button> -- add this code in the child component
  - if you want the child compnent to pass parameters to the parent, add parameters to the handler and in the child component transform it into an arrow function with parameters.
    - <button onClick={() => props.handler('child')}>Call Handler</button>
  - break the data flow means that an update to some prop won't be transmitted to a state.
Declarative Paradigm: style of programming where the focus is on what the program should accomplish rather than how it should accomplish it.
  - contrasts with imperative programming where you write explicit instructions on how to perform tasks.
  - eg: React, SQL, HTML, CSS, Functional Programming Languages like Haskell or Lisp.
Declarative Programming: you describe what each part of your UI should look like and React takes care of rendering the UI accordingly.
Destructuring: allows you to extract values from arrays or properties from Objects. In React, you can use them to extract values from props.
  - in FC, you extract them in the functions parameter. In CC, you extract them in the render() method with const {a, b} = this.props
Diffing: concept of comparing the virtual DOMs before and after the modification and ensuring efficient updates.
  - the result of the Conciliation process is called diff.
  - Diffing is related to the algorithm used to compare two virtual DOMs and is an important step in the Reconciliation process.
  - aka: DOM Diffing
Error Boundary: special component that lets you catch JavaScript errors and display/log some fallback UI instead of the part that crashed.
  - the Error Boundary is activated in production, but in development mode you want to make errors as high visible as possible (but in dev you'll have the option to close the error).
  - in class components, it is a CC that implements either one or both of componentDidCatch() or getDerivedStateFromError().
  - by default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an error boundary.
  - in React it is implemented using componentDidCatch() and the static getDerivedStateFromError() methods.
  - the Error Boundary component could have an UI to display some error message in case some state hasError is set true with getDerivedStateFromError(error), and display the normal component with the child props in case it has no error.
  - during development, react automatically logs every error to the console, so there is no need to console.log it again.
  - the place you put the Error Boundary is important as it controls if the entire app should have the fallback UI or just the component causing the problem.
Event Handling: events occur, at least, every time a user interacts with the UI.
  - eg: mouse clicks, mouse overs, key press, change event, so on.
  - in JSX, events are camel cased eg: onClick. in html they are lower case: onclick.
  - in JSX, you pass the handler in curly braces without parenthesis (otherwise it becomes a function call): onClick={clickHandler}. in html you pass as a string: onclick="clickhandler()".
fetch: react components don't know anything about HTTP, they simply read props and state and then render the UI.
  - to read data from the server you have to get the data to your props or state.
<Fragment>: often used via <>...</> syntax, lets you group elements without a wrapper node instead of an additional <div> tag.
  - it avoids the message JSX expressions must have one parent element.
  - there is an Explicit Syntax where you use the enclosing <React.Fragment> tag and there is a Short Syntax where you enclose with <></>.
  - an example where it could be very useful is inside a component that returns multiple <td>'s to be put inside a <tr>. If we wrap the <td>'s with div it would throw warnings, so we wrap with Fragment.
  - key attribut is the only attribute accepted by a Fragment. But with the Short Syntax you can't use the key attribute.
getDerivedStateFromError(error): takes the error as an argument and returns an object to update the state so that a specific UI for error could be rendered.
  - this is an Error Handling Phase Methods.
  - while getDerivedStateFromError() is used to update the state to render a fallback UI, componentDidCatch() can be used for side effects such as logging the error.
  - - the Error Boundary component could have an UI to display some error message in case some state hasError is set true with getDerivedStateFromError(error), and display the normal component with the child props in case it has no error.
getDerivedStateFromProps(props, state): it is a static method (does not have this keyword) that allows a component to update its state based on changes in its props.
  - it is not recommended to copy a prop directly into state since this breaks the data flow.
  - during the mounting phase, getDerivedStateFromProps() is called after the constructor and before render().
  - it is called in the Mounting and Update phases.
  - the method should return an object that represents the updated state of the component, or null if no state update is necessary.
  - getDerivedStateFromProps() serves as a safer, static alternative to the deprecated componentWillReceiveProps().
getSnapshotBeforeUpdate(prevProps, prevState): Updating Lifecycle Method that is called after the vDOM has been updated but before the changes are reflected in the actual DOM and you can calculate a snapshot, represented as the return value, to be used later in componentDidUpdate().
  - to calculate the snapshot you can use the previous Props, previous State, the actual Props, the actual state and the old DOM that for the moment is still the actual, just before the new changes in the vDOM are updated.
  - as major use cases we have: maintain scroll position, capture form input focus state, animate height changes.
  - one funny thing about getSnapshotBeforeUpdate() is that for hierarchical component trees, all the components will execute their getSnapshotBeforeUpdate() before they start their componentDidUpdate().
Higher-Order Component: function that takes a component and returns a new component.
  - it's a technique for reusing component logic like state. Lifting the state would be an option to share state and handler, but for components deeply separated it's better to use HOC.
  - HOCs are used to add additional functionality to a component without modifying it directly.
  - they are very similar to Decorator Pattern since they add functionality without modifying, and kinda favor composition over inheritance.
  - commonly used for cross-cutting concerns like authentication, state management and performance optimization.
  - both HOCs and Render Props are used for sharing logic and functionality between components.
  - use HOCs when the code involves states and other functions, use Render Props when the code you share is more related to pure JSX.
  - usually the function name of the HOC could be withSomething(...) and the parameter to that function could be called WrappedComponent, and the class that is returned by the function could be with pascal case WithSomething.
  - don't forget that when you pass a prop to a Component enhanced with a prop, actually you're passing the prop to the Parent component defined in the HOC, don't forget to pass down the props to the Component being enhanced in case you need it with {...this.props} or something like that.
  - if you need to pass parameters to the HOC to be used in some method, simply pass the parameter as a second parameter, right after the Component being enhanced.
Hooks: allow you to use React features without having to write a Class. The function name should start with the word 'use'.
  - using functions avoid the complexity of classes and the whole confusion with the 'this' keyword.
  - classes don't minify very well, so writing components with functions instead of classes is important.
  - you can reuse stateful code using hooks, without the need for complicated Components structure. You can reuse code in Class Components with HOCs and Render Props, but that's clumsy because adds to the Components Hierarchy.
  - Class Components usually have code split among different methods and that's bad. Data fetching for instance is divided between componentDidMount() and componentDidUpdate(). Subscription is divided among componentDidMount() componentWillUnmount().
  - Hooks, on the other hand, help organize the logic inside a component into reusable isolated units and not life cycles. UseEffect hook, for instance, concentrates all the effects code in just one place.
  - only call hooks at the top level. don't call hooks inside loops, conditions, or nested functions. only call them within React Functional components.
Hot Reloading: allows you to update and refresh parts of your application without requiring a full reload.
JSX: a syntax extension for JavaScript, often used with React to describe what the UI should look like.
  - lets you write HTML-like code in your JavaScript files.
  - stands for JavaScript XML.
  - at the end of the day, JSX is just synctatic sugar for function calls and objects construction.
  - JSX tags have a tag name, attributes and children.
  - the alternative to JSX was the React.createElement(..) function.
    - the first element is the html component name, the second are optionals and the third is the children.
  - usually we import React from 'react' to be able to use JSX.
  - JSX differences: Class -> className; for -> htmlFor; camelCase property naming convention.
  - {} curly braces are a feature of JSX that allows to embed JavaScript expressions within the markup. It allows you to incorporate logic and data into your JSX.
  - in JSX, events are camel cased eg: onClick. in html they are lower case: onclick.
key prop: each child in an array or iterator should have a unique "key" prop of the type string.
  - each item in the list rendered using the map operator should have it.
  - funny thing, in the child components, this key prop will not be accessible. It is reserved.
  - it is useful when iserting new items at the top of the list, since it will only need to mutate the first element and not the entire list.
  - keys give the elements a stable identity.
  - you could use the index (supplied by the map function as the second parameter) as key, but that's very stupid if you need to insert elements at the top of this list.
  - you could use the map index as key, if the list were static (never changed) and also never reordered or filtered.
Layout Components: specialized components that focus on organizing other components within a web page.
  - eg: split screen, lists, modals.
Lifecycle Methods: special methods that get called at different stages of a component's lifecycle and can be overwritten. They are available for Class Components.
  - useEffect hook partially accomplishes what lifecycle methods do with the advantage of keeping related code together and not divided in a method per cycle.
  - the methods can be classified in 4 phases 
    [1] Mounting: when an instance of a component is being created and inserted into the DOM.
      - constructor, getDerivedStateFromProps(), render and componentDidMount()
    [2] Updating: when a component is being re-rendered as a result of changes to either its props or state.
      - getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate() and componentDidUpdate()
    [3] Unmounting: when a component is being removed from the DOM.
      - componentWillUnmount()
    [4] Error Handling: when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.
      - getDerivedStateFromError() and componentDidCatch()
  - organizing the code per lifetime cycle instead of per functionality is bad because you have to put together code for different functionalities.
List Rendering: you can render lists by using map in the JSX but using {} to allow javascript expressions inside the JSX.
  - return (<div>{names.map(name => <h2>{name}</h2>)}</div>); or yet const nameList = names.map(name => <h2>{name}</h2>);
  - when you use map, each element in the map should have a unique "key" prop.
Memoization: performance optimization technique used to avoid unnecessary re-renders of components using shallow comparison.
  - check React.memo and useMemo().
Mounting Lifecycle Methods: methods which are called when the instance of a component is being created and inserted into the DOM.
  - constructor, getDerivedStateFromProps(), render and componentDidMount()
onClick: event attribute that allows you to specify JavaScript code to run when an element is clicked.
  - It can be used on many HTML elements, such as buttons, links, images, and divs.
  - you use camelCase (onClick) and pass a function directly rather than a string. eg: return ( <button onClick={handleClick}>Click Me!</button> );
  eg: <button onClick={() => setCount(count + 1)}>Count {count}</button>; note we pass some function definition instead of a function call. And prefer arrow function.
  - in HTML you call the function in the form of string. eg: <button onClick="alert('Button clicked!')">Click Me!</button>
One-way data flow: parent components pass data to their children via props, and children communicate back to parents only through callbacks.
Portals: provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component, in other words, outside the classical div with id='root'.
  - often used to handle cases where a component needs to visually break out of its container, such as for modals, tooltips, and dropdowns.
  - to use a Portal, that is, to render a tree into some DOM node, you use ReactDOM.createPortal(1,2) where the first parameter is the JSX to be rendered and the second is the DOM element you can get with document.getElementById('modal-root').
  - actually the first argument can be anything React can render, like numbers, strings, JSX and even React components.
  - a component can perfectly be declared inside some React node tree of components, but the render can be transfered to a Portal.
  - even though it renders in another DOM node, the rest continues exactly like any normal react component like event bubbling.
<Profiler>: lets you measure rendering performance of a React tree programmatically.
Props(react-ts-snippets.md#props): short for "property" is way of passing data from a parent component to a child component.
  - Props are immutable, that is, a component cannot change its own props.
  - they allow you to customize and configure the behavior and appearance of child components.
  - usually you receive a prop argument and use prop.argX... but it is more common to see the prop object being destructured.
  - if you don't know what you're gonne need to render, but want to render it anyway, pass it as children inside the open and closing tags of the component.
  - in Class Components the props are available through this.props. While in functional components you pass it through props parameter.
Props Drilling: process of passing data from a parent component to a deeply nested child component through multiple layers of intermediate components.
  - you can solve this issue using Context API or State Management Libraries like Redux, MobX, Recoil.
  - imagine that you have to pass a variable down to a Component nested five or ten levels deep, all the Components in between would have to forward the prop.
PureComponent: component that performs a shallow comparison on the component's props and state to determine if the component should re-render.
  - usually Components extend Component class from React, but you have the option to extend PureComponent.
  - instead of re-rendering for every setState(..), start re-rendering only if a shallow comparison show differences on state or props. It always re-render when some setState is called or some parent component re-renders.
  - This is an optimization technique using shallow copy to avoid unnecessary re-renders and improve the performance of your React application.
  - a Regular Component does not implement the shouldComponentUpdate method, a Pure Component implements shouldComponentUpdate with a shallow props and state comparison.
  - if you're dealing with arrays or objects, don't push elements into it when dealing with PureComponent, always return a new element.
  - if a Parent Component is a PureComponent, it won't re-render its child components when there are no changes in props or state.
  - it's safer to use Regular Components. Only use PureComponent if you see some performance boost hidden somewhere.
  - PureComponent only works with class components, while React.memo works with Functional Components.
React: a javascript library for building user interfaces.
React.Memo(): it's a high-order component that works similarly to React.PureComponent. That is, it returns a memoized version of the given component.
  - you can call the HOC with export default React.memo(ExpensiveComponent), for instance.
React.ReactNode: [ts] type of everything React can render.
Reconciliation: process of comparing the actual Virtual DOM with the previous one to calculate the minimal set of changes needed to update the actual DOM and the actual update to the DOM.
  - the whole Reconciliation process consists of Managing the lifecycle of updates, diffing, and applying the changes.
  - the differences between the two trees can be called "diffs".
  - Diffing is related to the algorithm used to compare two virtual DOMs and is an important step in the Reconciliation process.
  - it significantly improves performance compared to directly manipulating the DOM.
  - the updates to the actual DOM is made through javascript classic functions like createElement(), appendChild(), etc.
reducer: function that determines actions in an application imply in changes to an application's state.
  - in other words, it decouples Updates (how the states change) from Actions.
  - it is usually a pure function that is key to state management libraries like Redux.
  - function counterReducer(state, action) { switch action.type ... return newState }.
  - in FC you can useReducer via const [state, dispatch] = useReducer(reducer, initialState);
  - the state is decoupled from actions because to change the application's state you simply call dispatch({ type: 'tick' });
redux pattern: used for managing and centralizing application state.
  - Actions: object that must have a 'type' property that indicates the type of action being performed and could possibly have a payload.
  - Reducers: pure functions that take current state and action and return a new state. The state could be an object but also can be a primitive.
  - Store: object that holds the state of the application and provides methods to get the state, dispatch actions and subscribe to state changes.
Refs: way to access and interact with DOM elements or React Components directly.
  - there are two ways to create refs, the first and more common is Access Refs and the second and older one is Callback Refs.
  - many other use cases such as managing focus, text selection, etc.
  - in Class Components you create a ref using React.createRef() and attach it to a React element via the ref attribute of this element.
  - in Functional Components you create a ref using useRef(..);
  - with Callback Refs you attach the callback function to the React Element vie the ref attribute and the callback is called with the DOM element itself when the DOM mounts and null on unmount.
  - you can add refs to react components, this way it will be possible to call methods on a child component using the ref.
  - I believe it is possible to call methods not only on Class Components but also on Functional Components.
  - take a look at Forwarding Refs.
Refs Forwarding: with forward ref you can create a ref on a Parent Component and make it point to some element in the child component.
  - to do that:
    1. you simply create a normal ref in the parent component
    2. pass it down to the child component as ref prop
    3. wrap the child component in arrow function form in the HOC React.forwardRef()
    4. take the ref as argument before the prop
    5.  and pass down the reference to some element inside the child component as ref.
  - an option to some use cases would be to ref the child component and call some method on it.
render(): it basically read state and props and return JSX.
  - required lifecycle method in a class component that returns the React elements to be rendered to the DOM.
  - actually this method returns a virtual DOM reflecting the state of the UI, then React compares the new virtual DOM with the previous one and updates the actual DOM accordingly.
  - the process of comparing the new and the old virtual DOMs is called reconciliation, and the differences between the two trees can be called "diffs".
  - do not perform side effects like change state, interact with DOM or make fetch calls.
  - all the children components lifecycle methods are executed right after the render() execution of the parent component but just before the componentDidMount() of the parent.
Render Phase: purely computational phase which involves reconciling the new virtual DOM tree with the previous one, computing the differences (diffing), and preparing updates.
  - for the first render, react traverses the component tree starting at the root component and in each element it call the createElement() method transforming JSX components into a tree of React Elements (vDOM) which are JavaScript objects that describe the structure of your UI.
  ...when this phase ends and all react JSX components are converted into React Elements for the entire tree, all RE are handed over to the commit phase.
  - for re-renders, some components will be Flagged as needing updates. These flags can be triggered with useState or useReducer.
  ...for each of the flagged components react does the conversion from JSX into React Element. Then react compares the react elements in the previous render and in the new render (diffing). A list with all the changes needed to be made to the DOM and handed over to the commit phase.
  - rendering is not the same as updating the DOM.
Render Props: technique where a component accepts a function named render (or any other name) that produces JSX and possibly accept arguments, as a prop and uses that function to determine what to render.
  - the render(..) prop function that will be called by the render() method could even have parameters.
  - it's a technique for sharing code between react components using a prop whose value is a function.
  - the render() function of the Component will call the render prop, something like render() { return this.props.render(this.state) }
  - just like HOCs, you can use the Render Props pattern to share common functionality.
  - the way we share functionality in RP is by making a common parent Component with shared code like a common state but with rendering that uses the render props. The subComponent to be rendered will depend on which render function is passed.
  - ...then when you call the Parent component, you pass a render prop function that renders any child component you want to, this function may have parameters, that will take state in the Parent component and pass down to the child.
  - use Render Props when the code you share is more related to JSX and does not involve states and other functions.
  - there is a variation of RP where there is not necessary to pass a render(..) function. You simply pass the render function as child of the Container Component in curly braces and access it using this.children.render(..) instead of this.props.render(..).
  - the question of when to use HOCs and when to use render props can be complicated since they do very similar things.
rendering: process through which React translates the virtual representation of the UI (the virtual DOM) into actual UI elements that can be displayed and interacted with in the browser.
  - it is divided into two main phases: the render phase and the commit phase.
Request Memoization: type of cache that extends the fetch API to automatically memoize requests that have the same URL and options.
  - in a Component Tree, you don't need to fetch data at the top of the tree and forward props to optimize.
  - while Data Cache is a cache that works accross different renderings, Request Memoization works in the same rendering.
  - it is a React feature, not a Next.Js feature.
  - it is used to dedupe requests using React.cache.
  - only applies to GET method in fetch requests.
  - only applies within React Component Tree. Does not extend to fetch requests in Route Handlers.
root DOM node: a div with id="root" that React takes control and starts rendering stuff.
Route Component
serviceWorker: related to Progressive Web Apps (PWA).
shallow comparison: performed using ===, only looks at the first level of an object or array, and does not compare any nested objects or arrays.
  - for primitives, "first level" means that the operator checks if they are of the same type and have identical values.
  - for array or Objects (Complex Types), "first level" checks wheter the share the same reference in memory rather than comparing their contents.
  - inverse of deep comparison.
shouldComponentUpdate(): this is a method that takes nextProps and nextState as arguments and returns a boolean signaling if the component should re-render or not.
  - this is an exclusively Updating phase Lifecycle method executed right after the getDerivedStateFromProps() and right before the render().
  - this method is used to optimize performance preventing unnecessary renders.
  - shouldComponentUpdate() is required because even if setState(..) is called with the same actual state value the Component is re-rendered(), and this is non-optimal.
  - instead of implementing your own shouldComponentUpdate, you could use PureComponent which implements a shallow prop and state comparison for you.
Side Effects: actions that occur as a result of rendering but are not directly related to the output of the render function.
  - any operations that affect something outside the scope of a function, or operations that interact with the external world in a way that can affect the component or application state.
  - eg: data fetching, subscriptions (sockets, observables), timers, log, manually updating the DOM (not part of the natural render process), state management.
  - in Class Components you manage side effects with lifecycle methods componentDidMount, componentDidUpdate, componentWillUnmount.
  - in Functional Components we use useEffect to manage side effects.
State: stores dynamic data about a component.
  - it can be accessed through this.state in Class Components. In Functional Components it is accessed with useState(..) hook.
  - in Class Components don't update this.state directly, instead, use this.setState({...}). Else, the state is updated but not displayed in the UI.
  - the calls to setState are asynchronous! and hence, not immediately updated. If you want to execute something after the state is updated, pass the callback as the second parameter.
  - the setStates are grouped for better performance, so if you want to use multiple setState functions, pass a callback function as first parameter with prevState as parameter. This function can also have props.
State Lifting: technique used in React to manage shared state between multiple components. When two or more sibling components need to share the same state, the state is often lifted up to their closest common ancestor.
Stateless Functional Component: components declared via functions.
  - they used to have no state, but after hooks were introduced, even the functional components now can have state.
<StrictMode>: a development-only feature that lets you find common bugs in your components early during development.
  - Your components will re-render an extra time to find bugs like unexpected side effects caused by impure rendering.
  - Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
  - Your components will be checked for usage of deprecated APIs.
  - actually, the first double render is useful because people can place side effects outside the useEffect hook, which would be executed before generating the JSX and not after which is the default. To spot these errors, just render twice and check if they are exactly the same.
  - it is useful to use StrictMode in Development mode. When in production, react will automatically ignore it.
Styling React Components
  [1] CSS stylesheets: in this case you simpli import the CSS and the styles will automatically be applied to the Component.
  [2] Inline Styling: just create an object with properties as keys and values as values and use style={heading} in your components.
  [3] CSS Modules: is just like the CSS stylesheets but instead of using the class names as string, you use them as properties of a style object.
    - the advantage of CSS Modules is that the class has only local scope, while in CSS stylesheets the scope is also for all of its children components and hence is more error prone.
  [4] CSS in JS Libraries
super(props): all Class Components extends React.Component, so super calls the constructor of React.Component and passing props to it.
  - it correctly initializes this.state by calling super(). Don't forget that this is not defined before calling super() when there is inheritance.
<Suspense>: lets you display a fallback until its children have finished loading.
triggering: initiates a state update or a re-render of a component.
  - there are two reasons for a component to render [1] it's the component's initial render. [2] the component's (or one of its ancestors') state has been update. Remeber that an ancestors state could be another's prop.
  - usually the initial render is done by calling createRoot with the target DOM node and then calling its render method with your component.
  - the re-renders are triggered by updating its state with the set function.
Uncontrolled Components: form elements that manage their own state internally by keeping the state within the DOM itself.
  - you typically use React refs to access the values of uncontrolled components when needed.
  - to set initial values you use the defaultValue or defaultChecked attributes of the html input elements, instead of the initial value of the state in the case of Controlled Components.
  - use them for simple forms, scenarios where form state management is not necessary, or when integrating with third-party libraries that manipulate the DOM directly.
unmount: when you're displaying a component and it stops being displayed for any reason like a conditional display for instance.
'use client': lets you mark what code runs on the client.
  - will treat the module import as a boundary between server-run and client-run code.
  - the dependencies will also be evaluated on the client regardless of whether their modules contain a 'use client' directive.
useCallback(): used to memoize a function. It returns a memoized version of the callback function that only changes if one of the dependencies has changed.
  - remember that functions are rebuilt after every re-render and even though they have the same behavior, they differ because the comparison depends on reference equality. so all components with callback props like buttons are re-rendered.
  - just like useEffects, remember not to lie in the dependencies array and tell everything that the function being memoized depends (even harder to track dependencies).
  - useCallback() gives you referential equality between renders for functions.
  - useCallback() returns its function uncalled so you can call it later, while useMemo() calls its function and returns the result.
useContext(): allows you to subscribe to React context without introducing nesting code.
  [1] Create a Context: const ThemeContext = React.createContext('light'); export default ThemeContext;
  [2] Providing the Context: return ( <ThemeContext.Provider value={theme}>  <Toolbar />  </ThemeContext.Provider> );
  [3] Consume the Context: import ThemeContext from './ThemeContext'; ... const theme = useContext(ThemeContext); ...
useDebugValue():
useEffect(): hook that lets you synchronize a component with an external system.
  - it lets you perform side effects in function components and works similar to componentDidMount, componentDidUpdate, componentWillUnmount, etc.
  - side effects in this context are operations that affect something outside the scope of the function, such as data fetching, subscriptions, or manually changing the DOM.
  - usually you have to deal with loading states, error states and also racing conditions of multiple asynchronous fetches.
  - Class Components usually have code split among different methods and that's bad. Setting the document title, for instance, is divided between componentDidMount() and componentDidUpdate(). A timer would be divided between componentDidMount() and componentWillUnmount().
  - useEffect hook partially accomplishes what lifecycle methods do with the advantage of keeping related code together and not divided in a method per cycle.
  [1] Run Effect After Every Render: without any dependencies, the effect runs after the mount and after every render. useEffect( () => {...} );
  [2] Run Effects Only Once: if you pass an empty array [] as deps, the effect will run only once after the initial render.
  [3] Conditionally Run Effect: the dependencies (aka deps) is the second argument to useEffect in the form of an array of dependencies which can be props and states. The effect will run after the initial render and again whenever either the props or state changes.
  [4] Cleanup: if your effect returns a function, it is the Cleanup Function and React will run it when the component unmounts or before the effect runs again, to clean up the previous effect.
  - beware of the mental model when leaving the dependency array empty trying to mimic componentDidMount, like in Dan's post. Don't forget to put all that the effect depends directly or indirectly on the dependency array.
  - you can use more than one useEffect, gathering related code in each and making the code more clear.
  - the mental model of dependencies is that you have to signal to the useEffect what could change in the scope of the useEffect. You should not lie in the dependencies. Remember the Dan's classic setInterval bizarre example.
  - when you call functions inside the useEffect that are defined outside the useEffect it is easy to forget the states and props that the effect depends on, it is recommended to define these functions inside the useEffect.
  - other way to force the useEffect to take a look at the actual state of something would be to use the updater function of the state with the version containing setState.
useImperativeHandle():
useLayoutEffect():
useMemo(): useMemo() memoizes the result of a function so that you don't have to call an expensive function in every render.
  - useMemo gives you referential equality between renders for values.
  - useCallback() returns its function uncalled so you can call it later, while useMemo() calls its function and returns the result.
useReducer(): alternative to useState to manage state in React when the state logic is complex or involves multiple sub-values.
  - const [state, dispatch] = useReducer(reducer, initialState);
  - state: the current state.
  - dispatch: a function to send actions to the reducer.
  - newState = reducer(state, action): a function that contains the logic to update the state based on the received action.
    - state: the actual state, that will be changed. (actually since we don't call the reducer function directly we don't have to worry).
    - action: object containing type property and possibly other stuff such as payload.
    - usually this function is organized in switch form, possibly with a default case throwing new Error('...');
  - initialState: the initial state of the reducer.
  - the useReducer(reducer, initialState) is very similar to the array.reduce(reducer, initialValue) JavaScript method.
  - the useReducer may be used with a version with Simple State & Simple Action instead of follow the redux pattern, which means state with primitive instead of object and action with straightforward string instead of an object with type property.
  - the useReducer may be used with a Complex State and Action with state as Object and action as Object with type property.
  - you can use multiple useReducers to group logic, state transitions, etc in the same place.
  - usually you use useReducer for Local State Management at the Component Level. To share between components and use Global State Management use useReducer+useContext.
  - the complex data fetching with data state, loading state and error state can be implemented with useEffect and useReduce, instead of multiple useStates.
  - the switch cases in the reducer indicate actions or events that trigger state transitions, so the reducer has close liaison with event driven architecture.
  - useState x useReducer: if your states are primitives use uS, if objects or arrays use uR. If it has only one or two state transitionsuse uS if more uR. If the state transitions are related use uS else use uR.
  - ... if there is no Business Logic involved use uS, else uR. For local states use uS, for global states use uR.
  - the relation between render and useReducer is pretty similar to the one with useState.
useRef(): allows you to persist values between renders without causing a re-render when the value changes. Often used for accessing DOM elements directly and for storing mutable values that don't cause a re-render when updated.
  eg: const myRef = useRef(initialValue); and in the JSX <input ref={myRef} type='text' />
  - to access the element use myRef.current.
useState(): hook that lets you add a state variable to your component.
  - it is a function that accepts as argument the initial value of the state property and returns the current value of the state property and a function that is capable of updating this state property in array form and prone to array destructuring.
  eg: const [count, setCount] = useState(0);
  - const [state, setState] = useState(initialState)
  [1] create a Component [2] create a state variable initialized to 0 [3] create a method that is capable of setting this value. - note that useState performs these 3 steps in one line.
  - you can use a functional form of the state updates that takes into account the previous state and can be helpful in batched setStates. eg: setCount(prevCount => prevCount + 1);
  - react batches state updates for performance reasons and this could be troublesome to put setState() in for loops or timed operations. Prefer the functional form of the state updater.
  - for CC the state is always an object, but with useState hook the state doesn't have to be an object.
  - for states in the form of Objects while setState() in CC automatically merges the passed key-value pair with the rest of the Object, in FC the state updater from useState does not, so you have to use the spread operator ... eg: setName({ ...name, firstName: 'newName' })
  - for states in the form of Array we would have a similar problem and solve again with spread operator. eg: setItems([...items, {id:.., value:..}])
  - useState and Render: The setter function from a useState hook will cause the component to re-render.
    - The exception is when you update a State Hook to the same value as the current state.
    - The setState has the same value after the initial render? The component will not re-render.
    - The setState has the same value after re-renders (with different useStates)? React will render that specific component one more time and then bails out from any subsequent renders.
  - to re-render after setState, the setState must pass in or return a new reference as the state value.
  - in resume, react only bails-out a component from the rendering phase in 2 cases: [1] in initial render, if the state set is equal as before. [2] after re-renders it will render one more time and then bail out. Dan says that this is a safety net.
Virtual DOM: virtual representation of the actual DOM. When the state of a component changes, React creates a new Virtual DOM representation and then proceeds to perform a Reconciliation.
  - VDOM
Wrapper Component: it's a Component that wraps another component inside its tags and treat the inside component as its child component.
  - while HOCs wrap a component with a function, the Wrapper Component wraps a component within its tags.
  - HOCs add or modify behavior and are used to share logic, whereas Wrapper Components typically focus on layout, structure, or context and help organizing and structuring the UI.
================================================================================
React API

React.cloneElement(element, props, ...children): create a React element based on the element, but with different props and children.
  - we can use it as the base for Container Component Patterns like loaders, but we would have to pass a component as child without props, and then calling it later with other set of props. Typescript wouldn't like it.
React.isValidElement(value): checks whether a value is a React element.

================================================================================
React Libraries

MobX: state management library that makes it simple to manage and react to the state changes in your applications.
react-scripts: is an essential part of Create React App (CRA).
Recoil: state management library for React that aims to provide a more flexible and scalable way to manage state compared to traditional solutions like Redux.
Redux: popular state management library for JavaScript applications, often used with React.
  - key concepts: Store, Actions, Reducers, Dispatch, Selectors, Middleware.
Styled Components: allows you to write CSS in javascript files (CSS in JS lib)
Zustand: small, fast, and scalable state management library that simplifies managing global state in React applications.