- every time you see a repeating pattern, that is a candidate for a component.
- you should think carefully about component granularity.

================================================================================
React Glossary

Children: props.children holds the subcomponents that are nested inside the component definition.
  - they are hold in array form.
  - if you want more clarity, readibility and flexibility, use Children, as an alternative, if you want more control, pass the subcomponents as props.
Class Components: way to define components. They are ES6 classes that extend from React.Component and have a render() method that returns JSX.
  - you can add state via this.state.
  - they have lifecycle methods like componentDidMount(), componentDidUpdate(prevProps, prevState), componentWillUnmount().
className: prop used to specify a CSS class for an element.
  - class is a reserved word in JavaScript.
Component: modular, reusable and independently deployable pieces of code.
  - eg: pieces of UI in React. Each microservice.
Component: independent chunks of user interfaces.
  - you can have independent, isolated and reusable elements.
Component-Based Architecture: decompose a system into Components.
componentDidMount(): lifecycle method called after the component is mounted.
  - used for performing side-effects such as fetching data.
constructor(props): called before the component is mounted and used for initializing state and binding methods.
Controlled Component: when there is feedback, you change the input value, which is a state, and the component updates the state, which controls the value.
  - eg: <input value={input} onChange={(e) => setInput(e.target.value)} />
Core Content Components: primarily focused on displaying the main content and functionality of your application.
  - unlike layout components, which handle the overall structure and layout, core content components deal with the specific data, logic, and presentation of your application's content.
  - eg: article, UserProfile, ProductList, CommentForm.
createRoot(domNode): create a React root for displaying content inside a browser DOM element.
  - import ReactDOM from 'react-dom/client'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Greeting />);
  - import { createRoot } from 'react-dom/client'; const domNode = document.getElementById('root'); const root = createRoot(domNode); root.render(<App />);
  - probably this is the moment that Virtual DOM is created.
  - ReactDOM.createRoot(..) replaced ReactDOM.render(..).
Declarative Paradigm: style of programming where the focus is on what the program should accomplish rather than how it should accomplish it.
  - contrasts with imperative programming where you write explicit instructions on how to perform tasks.
  - eg: React, SQL, HTML, CSS, Functional Programming Languages like Haskell or Lisp.
Declarative Programming: you describe what each part of your UI should look like and React takes care of rendering the UI accordingly.
Diffing: concept of comparing the virtual DOMs before and after the modification and ensuring efficient updates.
  - aka: DOM Diffing
Error Boundary: special component that lets you display some fallback UI instead of the part that crashed.
  - by default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an error boundary.
<Fragment>: often used via <>...</> syntax, lets you group elements without a wrapper node.
Higher-Order Component: function that takes a component and returns a new component.
  - it's a technique for reusing component logic.
  - HOCs are used to add additional functionality to a component without modifying it directly.
  - they are very similar to Decorator Pattern since they add functionality without modifying, and kinda favor composition over inheritance.
  - commonly used for cross-cutting concerns like authentication, state management and performance optimization.
  - both HOCs and Render Props are used for sharing logic and functionality between components.
  - use HOCs when the code involves states and other functions, use Render Props when the code you share is more related to pure JSX.
JSX: a syntax extension for JavaScript, often used with React to describe what the UI should look like.
  - lets you write HTML-like code in your JavaScript files.
  - stands for JavaScript XML.
Layout Components: specialized components that focus on organizing other components within a web page.
  - eg: split screen, lists, modals.
Lifecycle Methods: special methods that get called at different stages of a component's lifecycle.
One-way data flow: parent components pass data to their children via props, and children communicate back to parents only through callbacks.
<Profiler>: lets you measure rendering performance of a React tree programmatically.
Props(react-ts-snippets.md#props): short for "property" is way of passing data from a parent component to a child component.
  - Props are immutable, that is, a component cannot change its own props.
  - they allow you to customize and configure the behavior and appearance of child components.
  - usually you receive a prop argument and use prop.argX... but it is more common to see the prop object being destructured.
React: a javascript library for building user interfaces.
React.FC: [ts] type of Functional Components.
React.JSX.Element: [ts] type of single React Element.
React.ReactNode: [ts] type of everything React can render.
render(): required lifecycle method in a class component that returns the React elements to be rendered to the DOM.
Render Props: technique where a component accepts a function as a prop and uses that function to determine what to render.
  - use Render Props when the code you share is more related to JSX and does not involve states and other functions.
Reconciliation: compares the actual Virtual DOM with the previous one to calculate the minimal set of changes needed to update the actual DOM.
  - it significantly improves performance compared to directly manipulating the DOM.
Request Memoization: type of cache that extends the fetch API to automatically memoize requests that have the same URL and options.
  - in a Component Tree, you don't need to fetch data at the top of the tree and forward props to optimize.
  - while Data Cache is a cache that works accross different renderings, Request Memoization works in the same rendering.
  - it is a React feature, not a Next.Js feature.
  - it is used to dedupe requests using React.cache.
  - only applies to GET method in fetch requests.
  - only applies within React Component Tree. Does not extend to fetch requests in Route Handlers.
root DOM node: a div with id="root" that React takes control and starts rendering stuff.
Route Component
serviceWorker: related to Progressive Web Apps (PWA).
<StrictMode>: lets you find common bugs in your components early during development.
  - Your components will re-render an extra time to find bugs caused by impure rendering.
  - Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
  - Your components will be checked for usage of deprecated APIs.
<Suspense>: lets you display a fallback until its children have finished loading.
'use client': lets you mark what code runs on the client.
  - will treat the module import as a boundary between server-run and client-run code.
  - the dependencies will also be evaluated on the client regardless of whether their modules contain a 'use client' directive.
useEffect(): hook that lets you synchronize a component with an external system.
useState(): hook that lets you add a state variable to your component.
  - const [state, setState] = useState(initialState)
Virtual DOM: virtual representation of the actual DOM. When the state of a component changes, React creates a new Virtual DOM representation and then proceeds to perform a Reconciliation.
  - VDOM