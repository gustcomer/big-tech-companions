
<Layout>
  <Template>
    <ErrorBoundary fallback={<Error />}>
      <Suspense fallback={<Loading />}>
        <ErrorBoundary fallback={<NotFound />}>
          <Page />
        </ErrorBoundary>
      </Suspense>
    </ErrorBoundary>
  </Template>
</Layout>

================================================================================
Nextjs glossary

App directory: directory responsible for all the routing.
  - to make it work, it has to have a page.tsx file inside the folder representing the routing. Check File Colocation.
Autoprefixer: lib that manages css prefixes like -webkit, -moz.
Catch-all Segments: extend dynamic segments to to catch-all subsequent segments.
  - add an ellipsis inside the brackets [...folderName]
  - all segments are passed at the params prop in an array form. (remember nested dynamic routes used key-value pairs).
  - app/shop/[...slug]/page.js will route /shop/a/b/c and generate params: { slug: ['a', 'b', 'c'] }
  - in the case above, if you want to also match app/, you should check Optional Catch-all Segments entry and use [[...slug]].
Client Components:
  - they can use hooks, use event listeners and manage state.
Cookies: small pieces of data that a server sends to a user's web browser.
  - the browser may store the cookie and send it back to the same server with later requests.
  - use cases: session management, personalizations, tracking and analysis of user behavior.
  - to set a cookie, send a response with "Set-Cookie" header and name-value: "Set-Cookie": "theme=dark"
  - to get a cookie from a request, use request.cookies.get("...")
  - as an alternative, you can use the cookies() function
cookies(): function to manipulate cookies
  - eg: cookies().set("resultsPerPage", "20")
  - and to get the cookies: cookies().get("resultsPerPage")
  - there are additional functionalities such as "has", delete, etc
Core Web Vitals: subset of Web Vitals.
  - consists of Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS).
Cumulative Layout Shift (CLS): measure of your site’s overall layout stability.
default.tsx: serves as a fallback to render content when the framework cannot retrieve a slot's active state from the current URL due to unmatched routes inside slots.
  - it's higly recommended that you have one default.tsx in each slot folder. You usually simply copy the code of the related page.tsx.
  - you should put a default.tsx in the parent folder that calls the slots as well.
  - this file processes slots without specific content for the route inside a slot.
  - I believe that you can put the same route inside different slots.
DELETE(): put this function inside a route.ts file to handle a DELETE request.
  - you can respond the request with return Response.json(...) or with return NextResponse.json({data})
  - export async function DELETE(_request: Request, {params}) {...}
Dynamic Page Route: the process of putting a page.tsx inside a folder representing a dynamic route.
Dynamic Route Handler: similar to Dynamic Page Route. Put a route.ts inside a folder representing a dynamic route.
  - useful for GET, PATCH, DELETE requests.
  - for GET: export async function GET(request: Request, { params }: { params: { id: string } })
Dynamic Routes: when you don't know the exact segment names ahead of time and want to create routes from dynamic data.
  - use Dynamic Segments for this purpose.
  - to use it you name the folder with square brackets, for example, [id] or [slug].
Dynamic Segment: when you don't know exact names of segment parts of the dynamic route, you can use Dynamic Segments to capture this dynamic data.
  - created by wrapping a folder's name in square brackets: [folderName]
  - they are passed as the params prop to layout, page, route, and generateMetadata functions.
error.tsx
  - the error component automatically creates a React Error Boundary that wraps a nested child segment or page.js component.
  - this error component receives and error object with an Error object containing information about the error.
  - also it receives a reset method, reset: () => void, that allows to retry if we end up in the Error Boundary (the Error Page).
  - by positioning error.tsx at different levels in the nested folders, you can achieve a more granular level of error handling.
Error Handling:
  - error boundaries must be client components in Next. 
  - a prop called error is passed to the Error component. You can get the error message from it.
  - in nested routes, errors bubble up to the closest parent error boundary.
  - taking into account the next structure, inserting an error.tsx will handle errors of the page at the same folder, but won't handle errors in the template nor the layout.
  - to handle errors in the layout or in the template, you should place error.tsx one folder above.
File Colocation: practice of organizing and grouping related files together in the same directory.
  - but in the App folder responsible for the routing, the route only has visibility if it has a page.tsx file and an export default component.
generateMetadata(): function used to define dynamic metadata.
  - you cannot export a static metadata and a generateMetadata function at the same time.
GET(): put this function inside a route.ts file to handle a get request.
  - you can respond the request with return Response.json(...) or with return NextResponse.json({data})
  - export async function GET(_request: Request, {params}) {...}
HTTP Headers: metadata associated with an API request and response.
<Image>: 
  - required props: src, width, height, and alt.
  - fill(prop): causes the image to fill the parent element, which is useful when the width and height are unknown.
Independent Route Handling: each slot can have its own loading and error states.
Intercepting Routes: allows you to load a route from another part of your application within the current layout when navigation through <Link/>.
  - if you refresh the page or type the address directly, it will show the original page, and not the intercepted one.
  - use case: show login modal when you're navigating, but show login page when you share the link or refresh.
  - define naming a subfolder as /(.)routename , this way it opens /(.)routename when clicking <Link/> and /routname when refreshing or sharing the link.
  - if the route you want to intercept is at the same level of your current route, use /(..)routename.
  - (.) match segments on the same level.
  - (..) match segments one level above.
  - (..)(..) match segments two levels above (has bugs).
  - (...) match segments from the root app directory.
key prop: string or a number that uniquely identifies items in an array.
Layout: UI that is shared between multiple routes. On navigation, layouts preserve state, remain interactive, and do not re-render.
  - The component should accept a children prop and this chindren component will be inserted into the UI.
layout.tsx: special file that is shared between multiple routes and defines UI.
  - export some component as default and with children props.
Layout Shifting: when a visible element on your page changes position or size, affecting the position of content around it.
<Link>: component that extends the HTML <a> element to provide prefetching and client-side navigation between routes.
  - eg: <Link href="/blog">Blog</Link>
  - replace prop: when true, next/link will replace the current history state instead of adding a new URL into the browser’s history.
loading.tsx: this file allows us to create loading states that are displayed to users while a specific route segment's content is loading.
  - loading has to do with React Suspense.
Metadata API: allows you to define metadata for each page.
  - 2 methods: export a static metadata object or export a dynamic generateMetadata().
  - deeper page metadata will replace layout metadata if they have the same properties.
Middleware: allows you to run code before on the incoming request. You can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.
  - Use the file middleware.ts (or .js) in the root of your project to define Middleware.
  - the matcher config property is used to filter Middleware to run on specific paths.
Nested Dynamic Routes: nested routes with more than one dynamic segment.
  - all dynamic segments will be passed as properties of Param props in the form of key-value pairs.
  - other way to capture multiple dynamic segments is using Catch All Segments.
Nested Layout: layouts in the folder hierarchy are nested, which means they wrap child layouts via their children prop.
Nested Routes: ability to create a hierarchical structure of pages that reflects a path hierarchy in the URL.
  - just pile up the folders.
NextRequest: extends the Request Web Request API with additional convenience methods.
  - with request.nextUrl.searchParams we can access all query parameters.
  - check Request
Not Found Page: 404 not found page when the next router doesn't find any match, or programatically with notFound() function.
  - you customize the Not Found Page creating a not-found.tsx file.
  - it creates an ErrorBoundary.
not-found.tsx: file responsible for the customization of the Not Found Pages.
notFound(): function that calls the Not Found Page.
Optional Catch-all Segments: like catch all segments but will also match the original route;
  - use double square brackets [[..segmentName]].
page.tsx: special file that is unique to a route allows you to create UI for it.
  - put page.tsx exporting some component as default.
Parallel Routes: advanced routing mechanism that uses Slots and allows for the simultaneous rendering of multiple pages within the same layout.
  - useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.
  - you can have routes inside slots and this brings Unmatched Routes in other slots specially on page reloads. Treat it with default.tsx.
params: prop used to capture the value of dynamic segments as key-value pairs.
  - it is passed as prop to layout, page, route, and generateMetadata functions.
PATCH(): put this function inside a route.ts file to handle a PATCH request.
  - you can respond the request with return Response.json(...) or with return NextResponse.json({data})
  - export async function PATCH(_request: Request, {params}) {...}
POST(request): put this function inside a route.ts file to handle a post request.
  - use request parameter to access request body.
Postcss: tool for transforming CSS with JavaScript.
Prefetching: when a <Link /> component enters the user's viewport (initially or through scroll) Next.js prefetches and loads the linked route (denoted by the href) and data in the background to improve the performance of client-side navigations.
Private Folder: indicate that it is a private implementation and should not be considered by the routing system.
  - prefix the folder name with an underscore _. The folder and all its subfolders are excluded from routing.
redirect(): redirect the user to another URL.
  - can be used in Server Components, Route Handlers, and Server Actions.
Request: interface of the Fetch API representing a resource request
  - it has the Request type and lots of methods to return
  - in Next, it is preferable to use the NextRequest since it provides extra methods.
Request Headers: metadata sent by the client
  - 'User-Agent': identifies the browser and operating system. Useful for specific renderings and analytics.
  - 'Accept': indicates content types the Client can process. The server has the option to respond with one of these.
  - 'Authorization': header used by the client to authenticate itself to the server.
reset(): an error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the Error boundary's contents.
  - the cause of an error can sometimes be temporary. In these cases, simply trying again might resolve the issue.
Response(): interface of the Fetch API represents the response to a request.
  - check Response() in javascript glossary.
  - there is a better alternative with NextResponse which provide additional convenience methods.
  - if you want to respond with code, pass a second object parameter with headers and status fields. Check documentation.
  - the second argument is the headers object, check documentation if you want to change "Content-Type" to text/html, for instance.
Response Headers: metadata sent back from the server to the client.
  - 'Content-Type': header that indicates the media type of the response. eg: text/html, application/json, etc.
Root Layout: defined at the top level of the app directory and applies to all routes.
  - you can't get rid of this layout file. If you delete, it will reappear.
  - besides a normal Layout, it must contain html and body tags.
Route Group: organize your route segments and project files into logical groups without affecting the URL path structure.
  - wrap a folder's name in parenthesis: (folderName)
  - you can use layout files specific to the route group.
Route Group Layout: apply a layout to pages grouped by a Route Group.
  - you can create a specific rout group named (with-specific-layout).
Route Handlers: allow you to create custom request handlers for a given route using the Web Request and Response APIs.
  - use the file route.ts instead of page.ts in the App folder.
  - while page routes respond with html, route handlers allow you to create RESTful endpoints and respond with json, for instance.
  - you don't need to create and configure a separate server! no need to express.js
  - they run on server-side, can access databases, etc.
  - while page routes are router in the frontend, route handlers are routing in the backend.
route.ts: file responsible for route handlers.
  - export async function GET() {return Response.json({ message: 'Hello - GET' });}
  - If there are page.ts and route.ts files in the same folder, page.ts takes precedence.
Routing: Next.js uses a file-system based routing mechanism.
Server Action: asynchronous functions that are executed on the server.
  - place the directive "use server" at the top of an async function.
Server Components:
  - they can access the server. but they can't use hooks, event listeners or manage state.
Slots: pieces of UI that do not represent routes and are defined with the @folder convention.
  - if you try to access them via route, you'll get a 404.
  - each slot allows for Independent Route Handling.
  - each slot allows for Sub-navigation, that is, they function as a mini-application.
  - you can place routes inside a slot folder, in that case, when accessing via <Link/> the rest of the slots will stay with current state.
  - if you access a slot inside a route refreshing the page, all non defined slots will fallback on a default.tsx, or throw a 404 if any of them don't have one.
Static Metadata File: defines metadata in form an object that can be placed in Pages and Layouts.
  - eg: export const metadata = {title: "Next.js", description: "Generated by Next.js"}
Sub-navigation: inside a slot, you can navigate to a different slot, without reloading the whole page.
Template: similar but different from Layout. When a user navigates between routes that share a template, a new instance of the component is mounted.
  - DOM elements are recreated, state is not preserved, effects are re-synchronized.
template.tsx: name of the file to declare a template.
title metadata: define the document title. It can be passed as a string in the key-value pair of the metadata, or as an object.
  - the object version has 3 keys: absolute, default and template.
  default: provides a default title to child elements that don't explicity specify a title.
  template: act as a layout for children pages.
  absolute: will ignore any template title set in parents.
Unmatched Routes: when slots have subroutes inside them, sibling slot may not have the same route.
URL Query Parameters: pass parameters to the request using ?query= notation in the URL
  - eg: localhost:3000/comments?query=first
  - with request.nextUrl.searchParams we can access all query parameters.
  - usually is used to filtering requests.
usePathname(): hook provided by Next.js that supplies the current route name (url after the domain).
  - it is useful to check which <Link> is active to give proper styling.
useRouter(): hook that allows you to access the router object inside any function component in your app.
  - with the router object, you can navigate Programatically.
  - router.push(/): handles client-side transitions
  - router.replace(): prevent adding a new URL entry into the history stack.
  - router.back(): navigate back in history.
  - router.reload(): reload the current URL.
Web Vitals: initiative created by Google to provide unified guidance and metrics to measure end-user page experience on the web.