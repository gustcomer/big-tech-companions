
<Layout>
  <Template>
    <ErrorBoundary fallback={<Error />}>
      <Suspense fallback={<Loading />}>
        <ErrorBoundary fallback={<NotFound />}>
          <Page />
        </ErrorBoundary>
      </Suspense>
    </ErrorBoundary>
  </Template>
</Layout>

================================================================================
Nextjs glossary

App directory: directory responsible for all the routing.
  - to make it work, it has to have a page.tsx file inside the folder representing the routing. Check File Colocation.
Autoprefixer: lib that manages css prefixes like -webkit, -moz.
Catch-all Segments: extend dynamic segments to to catch-all subsequent segments.
  - add an ellipsis inside the brackets [...folderName]
  - all segments are passed at the params prop in an array form. (remember nested dynamic routes used key-value pairs).
  - app/shop/[...slug]/page.js will route /shop/a/b/c and generate params: { slug: ['a', 'b', 'c'] }
  - in the case above, if you want to also match app/, you should check Optional Catch-all Segments and use [[...slug]].
Client Components:
  - they can use hooks, use event listeners and manage state.
Core Web Vitals: subset of Web Vitals.
  - consists of Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS).
Cumulative Layout Shift (CLS): measure of your site’s overall layout stability.
default.tsx: serves as a fallback to render content when the framework cannot retrieve a slot's active state from the current URL due to unmatched routes inside slots.
  - it's higly recommended that you have one default.tsx in each slot folder. You usually simply copy the code of the related page.tsx.
  - you should put a default.tsx in the parent folder that calls the slots as well.
  - this file processes slots without specific content for the route inside a slot.
  - I believe that you can put the same route inside different slots.
Dynamic Routes: when you don't know the exact segment names ahead of time and want to create routes from dynamic data.
  - use Dynamic Segments for this purpose.
  - to use it you name the folder with square brackets, for example, [id] or [slug].
Dynamic Segment: when you don't know exact names of segment parts of the dynamic route, you can use Dynamic Segments to capture this dynamic data.
  - created by wrapping a folder's name in square brackets: [folderName]
  - they are passed as the params prop to layout, page, route, and generateMetadata functions.
error.tsx
  - the error component automatically creates a React Error Boundary that wraps a nested child segment or page.js component.
  - this error component receives and error object with an Error object containing information about the error.
  - also it receives a reset method, reset: () => void, that allows to retry if we end up in the Error Boundary (the Error Page).
  - by positioning error.tsx at different levels in the nested folders, you can achieve a more granular level of error handling.
Error Handling:
  - error boundaries must be client components in Next. 
  - an prop called error is passed to the Error component. You can get the error message from it.
  - in nested routes, errors bubble up to the closest parent error boundary.
  - taking into account the next structure, inserting an error.tsx will handle errors of the page at the same folder, but won't handle errors in the template nor the layout.
  - to handle errors in the layout or in the template, you should place error.tsx one folder above.
File Colocation: practice of organizing and grouping related files together in the same directory.
  - but in the App folder responsible for the routing, the route only has visibility if it has a page.tsx file and an export default component.
generateMetadata(): function used to define dynamic metadata.
  - you cannot export a static metadata and a generateMetadata function at the same time.
<Image>: 
  - required props: src, width, height, and alt.
  - fill(prop): causes the image to fill the parent element, which is useful when the width and height are unknown.
Independent Route Handling: each slot can have its own loading and error states.
Intercepting Routes: allows you to load a route from another part of your application within the current layout.
  - use case: show login modal when you're navigating, but show login page when you share the link or refresh.
  - define naming a subfolder as /(.)routename , this way it opens /(.)routename when clicking <Link/> and /routname when refreshing or sharing the link.
  - if the route you want to intercept is at the same level of your current route, use /(..)routename.
  - (.) match segments on the same level.
  - (..) match segments one level above.
  - (..)(..) match segments two levels above (has bugs).
  - (...) match segments from the root app directory.
key prop: string or a number that uniquely identifies items in an array.
Layout: UI that is shared between multiple routes. On navigation, layouts preserve state, remain interactive, and do not re-render.
  - The component should accept a children prop and this chindren component will be inserted into the UI.
layout.tsx: special file that is shared between multiple routes and defines UI.
  - export some component as default and with children props.
Layout Shifting: when a visible element on your page changes position or size, affecting the position of content around it.
<Link>: component that extends the HTML <a> element to provide prefetching and client-side navigation between routes.
  - eg: <Link href="/blog">Blog</Link>
  - replace prop: when true, next/link will replace the current history state instead of adding a new URL into the browser’s history.
loading.tsx: this file allows us to create loading states that are displayed to users while a specific route segment's content is loading.
  - loading has to do with React Suspense.
Metadata API: allows you to define metadata for each page.
  - 2 methods: export a static metadata object or export a dynamic generateMetadata().
  - deeper page metadata will replace layout metadata if they have the same properties.
Middleware: allows you to run code before on the incoming request. You can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.
  - Use the file middleware.ts (or .js) in the root of your project to define Middleware.
  - the matcher config property is used to filter Middleware to run on specific paths.
Nested Dynamic Routes: nested routes with more than one dynamic segment.
  - all dynamic segments will be passed as properties of Param props in the form of key-value pairs.
  - other way to capture multiple dynamic segments is using Catch All Segments.
Nested Layout: layouts in the folder hierarchy are nested, which means they wrap child layouts via their children prop.
Nested Routes: ability to create a hierarchical structure of pages that reflects a path hierarchy in the URL.
  - just pile up the folders.
Not Found Page: 404 not found page when the next router doesn't find any match, or programatically with notFound() function.
  - you customize the Not Found Page creating a not-found.tsx file.
  - it creates an ErrorBoundary.
not-found.tsx: file responsible for the customization of the Not Found Pages.
notFound(): function that calls the Not Found Page.
Optional Catch-all Segments: like catch all segments but will also match the original route;
  - use double square brackets [[..segmentName]].
page.tsx: special file that is unique to a route allows you to create UI for it.
  - put page.tsx exporting some component as default.
Parallel Routes: advanced routing mechanism that uses Slots and allows for the simultaneous rendering of multiple pages within the same layout.
  - useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.
  - you can have routes inside slots and this brings Unmatched Routes in other slots specially on page reloads. Treat it with default.tsx.
params: prop used to capture the value of dynamic segments as key-value pairs.
  - it is passed as prop to layout, page, route, and generateMetadata functions.
Postcss: tool for transforming CSS with JavaScript.
Prefetching: when a <Link /> component enters the user's viewport (initially or through scroll) Next.js prefetches and loads the linked route (denoted by the href) and data in the background to improve the performance of client-side navigations.
Private Folder: indicate that it is a private implementation and should not be considered by the routing system.
  - prefix the folder name with an underscore _. The folder and all its subfolders are excluded from routing.
redirect(): redirect the user to another URL.
reset(): an error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the function will try to re-render the Error boundary's contents.
  - the cause of an error can sometimes be temporary. In these cases, simply trying again might resolve the issue.
Response(): interface of the Fetch API represents the response to a request.
  - check Response() in javascript glossary.
Root Layout: defined at the top level of the app directory and applies to all routes.
  - you can't get rid of this layout file. If you delete, it will reappear.
  - besides a normal Layout, it must contain html and body tags.
Route Group: organize your route segments and project files into logical groups without affecting the URL path structure.
  - wrap a folder's name in parenthesis: (folderName)
  - you can use layout files specific to the route group.
Route Group Layout: apply a layout to pages grouped by a Route Group.
  - you can create a specific rout group named (with-specific-layout).
Route Handlers: allow you to create custom request handlers for a given route using the Web Request and Response APIs.
  - use the file route.ts instead of page.ts in the App folder.
  - while page routes respond with html, route handlers allow you to create RESTful endpoints and respond with json, for instance.
  - you don't need to create and configure a separate server! no need to express.js
  - they run on server-side, can access databases, etc.
  - while page routes are router in the frontend, route handlers are routing in the backend.
route.ts: file responsible for route handlers.
  - export async function GET() {return Response.json({ message: 'Hello - GET' });}
  - If there are page.ts and route.ts files in the same folder, page.ts takes precedence.
Routing: Next.js uses a file-system based routing mechanism.
Server Action: asynchronous functions that are executed on the server.
  - place the directive "use server" at the top of an async function.
Server Components:
  - they can access the server. but they can't use hooks, event listeners or manage state.
Slots: pieces of UI that do not represent routes and are defined with the @folder convention.
  - if you try to access them via route, you'll get a 404.
  - each slot allows for Independent Route Handling.
  - each slot allows for Sub-navigation, that is, they function as a mini-application.
  - you can place routes inside a slot folder, in that case, when accessing via <Link/> the rest of the slots will stay with current state.
  - if you access a slot inside a route refreshing the page, all non defined slots will fallback on a default.tsx, or throw a 404 if any of them don't have one.
Static Metadata File: defines metadata in form an object that can be placed in Pages and Layouts.
  - eg: export const metadata = {title: "Next.js", description: "Generated by Next.js"}
Sub-navigation: inside a slot, you can navigate to a different slot, without reloading the whole page.
Template: similar but different from Layout. When a user navigates between routes that share a template, a new instance of the component is mounted.
  - DOM elements are recreated, state is not preserved, effects are re-synchronized.
template.tsx: name of the file to declare a template.
title metadata: define the document title. It can be passed as a string in the key-value pair of the metadata, or as an object.
  - the object version has 3 keys: absolute, default and template.
  default: provides a default title to child elements that don't explicity specify a title.
  template: act as a layout for children pages.
  absolute: will ignore any template title set in parents.
Unmatched Routes: when slots have subroutes inside them, sibling slot may not have the same route.
usePathname(): hook provided by Next.js that supplies the current route name (url after the domain).
  - it is useful to check which <Link> is active to give proper styling.
useRouter(): hook that allows you to access the router object inside any function component in your app.
  - with the router object, you can navigate Programatically.
  - router.push(/): handles client-side transitions
  - router.replace(): prevent adding a new URL entry into the history stack.
  - router.back(): navigate back in history.
  - router.reload(): reload the current URL.
Web Vitals: initiative created by Google to provide unified guidance and metrics to measure end-user page experience on the web.